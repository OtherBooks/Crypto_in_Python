% this next line updated by emacs every time the file is saved:
\def\tsval{Time-stamp: < 11 Jun 2021 10:35MDT >}
%
% 
%    Open Workbook of Cryptology
%      by Jonathan A. Poritz
%       jonathan@poritz.net  and  http://www.poritz.net/jonathan
%       This work is licensed under the Creative Commons Attribution-
%         ShareAlike 4.0 International License. To view a copy
%         of this license, visit
%         http://creativecommons.org/licenses/by-sa/4.0/.
%
%    You are free to share and adapt this book for any purpose, even
%        commercially (that's what the CC license is about) but:
%          -- you must give appropriate credit to this author and to 
%          -- you must indicate in your version if you have made changes to our
%             originals, and
%          -- if you remix, transform, or build upon the material, you must
%             distribute your contributions under the same license as the
%             original
%          -- you may not apply legal terms or technological measures which
%             restrict others from doing anything the license permits.
%
%    While this is not a legal requirement, I would be happy to know if you are
%          using and/or adapting this work: please send such information to my
%          e-mail address jonathan.poritz@gmail.com  For that matter, if you
%          find typos or have suggestions of things to change or add, I would
%          be happy to hear that as well.
%
%
%
% --------------------------------------------------------------------------
% Some notes on using this TeX file:
%
%  It is standard LaTeX -- my version says
%   'This is pdfTeX, Version 3.1415926-2.4-1.40.13 (TeX Live 2012/Debian)'
%   at the start of the run.  It does use quite a few packages, but they are
%   all available from the standard 'net repositories ... in fact, I installed
%   nothing particularly for this book.
%
%  Here is how I produce the final owoc.pdf file on my Linux box
%    (on other systems, you will know how that must be changed)
%      pdflatex owoc
%      bibtex owoc
%      pdflatex owoc
%      pdflatex owoc
%      makeindex owoc
%      pdflatex owoc
%      view owoc.pdf in my favorite viewer (I use 'evince')
%
%  Note you will need the following files in the directory where you do this:
%      owoc.tex
%      refs.bib
%      owoc_cover.eps
%      by-sa.eps
%      all_the_animals_freq.pdf
%      vig_all_the_animals_freq.pdf
%      caesar10_all_the_animals_freq.pdf
%      
%  You should be able to customize this, or extract parts from it for your own
%    use fairly easily.  I tried to follow good, clear, TeX style: for example,
%    labels, for references to definitions, theorems, sections, etc., all
%    follow a fairly uniform naming convention which should be obvious just by
%    looking at a few.
%
%
%
\documentclass[12pt,letterpaper]{amsbook}
\usepackage[text={6in,9in},centering]{geometry}
\usepackage[listings,breakable,theorems,skins]{tcolorbox}
\usepackage{listings}
\usepackage{adjustbox}
\usepackage{fancybox}
\usepackage{fancyvrb}
\usepackage{wrapfig}
\usepackage{times}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz-cd}
\usepackage{tikz}
\usetikzlibrary{calc,shapes.multipart,chains,arrows}
\tikzset{
place/.style={
       rectangle split,
       rectangle split parts=3,
       draw=black, very thick,
       minimum height=2em,
       text width=3cm,
       inner sep=2pt,
       text centered,
       }
}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage[hyphenbreaks]{breakurl}
\usepackage{graphicx}
\usepackage{float}
\usepackage{multirow}
\usepackage{afterpage}
\usepackage{environ}
\usepackage{xcolor}
\usepackage{pagecolor}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{examples}[theorem]{Examples}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{exercise}{Exercise}
\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}
\newtheorem{fact}[theorem]{Fact}
\numberwithin{figure}{section}
\numberwithin{exercise}{chapter}
\numberwithin{section}{chapter}
\numberwithin{equation}{section}
\numberwithin{table}{subsection}
%macros for dealing with the emacs timestamp
\def\tsgutsb#1{\expandafter\tsgutsa #1\relax}
\def\tsgutsa#1 #2 #3 #4 #5 #6 #7\relax{#3 #4 #5  #6}
\def\timestamp{\tsgutsb{\tsval}}
\newtcbtheorem[number within=section]{AZtcb}{Reading Response}%%%
{enhanced,breakable,colback=blue!5,colframe=blue!35!black,fonttitle=\bfseries}{az}%%%
\newtcbtheorem[number within=section]{CTtcb}{Code Task}%%%
{enhanced,breakable,colback=green!5,colframe=green!35!black,fonttitle=\bfseries}{az}%%%
\newtcbtheorem[number within=section]{BTtcb}{Bonus Task}%%%
{enhanced,breakable,colback=purple!5,colframe=purple!35!black,fonttitle=\bfseries}{az}%%%
\newenvironment{preface}{}{}
\newenvironment{releasenotes}{}{}
\newenvironment{discussion}{}{}
\newcommand{\dispcodestart}{\hfil\newline\begin{BVerbatim}[bgcolor=lg]}
\newcommand{\dispcodeend}{\end{BVerbatim}}
\DefineVerbatimEnvironment{codedisp}{BVerbatim}{frame=single,bgcolor=lg,rulecolor=\color{black},baseline=t}
\newcommand{\code}[1]{\colorbox{lg}{\texttt{#1}}}
\newcommand{\Python}{{\textbf{\ix{Python}}}}
\newcommand{\Pythonthree}{{\textbf{Python 3}}}
\newcommand{\blue}[1]{{\color{blue}#1}}
\newcommand{\red}[1]{{\color{red}#1}}
\newcommand{\gray}[1]{{\color{gray}#1}}
%\newcommand{\bhref}[2]{{\href{#1}{\blue{#2}}}}
\newcommand{\bhref}[2]{\href{#1}{#2}}
\newcommand{\blurl}[1]{\bhref{#1}{#1}}
\newcommand{\ix}[1]{{#1}\index{#1}}
\newcommand{\Aa}{{\mathcal A}}
\newcommand{\Ss}{{\mathcal S}}
\definecolor{lg}{rgb}{0.92, 0.92 0.92}
\makeatletter
\newif\ifFV@bgcolor
\newbox\FV@bgbox
\define@key{FV}{bgcolor}{\FV@bgcolortrue\def\FV@bgcolor{#1}}
\def\FV@BeginVBox{%
  \leavevmode\ifFV@bgcolor\setbox\FV@bgbox=\fi
  \hbox\ifx\FV@boxwidth\relax\else to\FV@boxwidth\fi\bgroup
  \ifcase\FV@baseline\vbox\or\vtop\or$\vcenter\fi\bgroup}
\def\FV@EndVBox{\egroup\ifmmode$\fi\hfil\egroup
  \ifFV@bgcolor\colorbox{\FV@bgcolor}{\box\FV@bgbox}\fi}
\makeatother
\makeatletter
\providecommand{\leftsquigarrow}{%
  \mathrel{\mathpalette\reflect@squig\relax}%
}
\newcommand{\reflect@squig}[2]{%
  \reflectbox{$\m@th#1\rightsquigarrow$}%
}
\makeatother
\renewcommand{\seename}{see}
\linespread{1.2}
\setlength{\shadowsize}{1pt}
\makeindex

\begin{document}
\newpagecolor{purple}
\lstset{language=Python,
        backgroundcolor=\color[rgb]{.95,.95,.97},
        frame=single,}
\frontmatter

%\title{\ \vskip-3cm\includegraphics[width=10cm,clip]{owoc_cover.eps}\\\huge\color{white} Open Workbook of Cryptology\\
%  {\LARGE\it A project-based introduction to crypto in Python}}
  \title{A project-based introduction to crypto in Python}}

% \author{{\color{green}{\Large\bf Jonathan A.~Poritz}}}
\author{Jonathan A.~Poritz}
\address{\color{yellow}\centerline{\bf Department of Mathematics and Physics\hphantom{XXXXX}}
  \centerline{\bf Colorado State University, Pueblo}
  \centerline{\bf 2200 Bonforte Blvd.}
  \centerline{\bf Pueblo, CO 81001, USA}
  \centerline{{\bf E-mail: jonathan@poritz.net}}
  \centerline{{\bf Web: poritz.net/jonathan}}
  \vskip2.5cm\hfill\tiny\timestamp}

\maketitle
\restorepagecolor

\chapter*{Release Notes}\label{chap:release-notes}

This is a first draft of a free (as in speech, not as in beer,
\cite{stallman2002free}) (although it is free as in beer as well) textbook
for a one-semester, undergraduate cryptology course.  It was used for CIS 491
at Colorado State University Pueblo in the spring semester of 2021.

It's not clear that any other instructor would feel comfortable using this
version, without a lot of adaptation.  In fact, I usually find that when I
write an open textbook like this one, during the semester in which I am
teaching the class, what results is a little rough and has a few real gaps.
After another semester teaching with this book, the second version (which
could well be twice as long!)  will likely be much easier to use by others.

Nevertheless, in the spirit of openness, I'm sharing this first draft as
well: if you want to use it for self-study or in a class you are teaching,
feel free to do so -- just makes sure your seatbelt is fastened, as the ride
might be a little bumpy at times.  [That said, if you do use this and find
typos, thinkos, or other issues, I would be grateful if you would tell me
about them!]

As I make improvements and additions to this work, you will always be able to
find them on the page \burl{https://poritz.net/jonathan/share/owoc/}, so please
look there for the best version.

\begin{wrapfigure}[4]{r}{0.25\textwidth}
  \begin{center}
    \includegraphics[height=1.25cm,clip]{by-sa.eps}
  \end{center}
\end{wrapfigure}
I am releasing this work under a {\bf Creative Commons Attribution-ShareAlike
4.0 International} license, which allows anyone to \textbf{share} (copy and
redistribute in any medium or format) and \textbf{adapt} (remix, transform,
and build upon this work for any purpose, even commercially).  These rights
cannot be revoked, so long as users follow the license terms, which
require \textbf{attribution} (giving appropriate credit, linking to the
license, and indicating if changes were made) to be given
and \textbf{share-alike} (if you remix or transform this work, you must
distribute your contributions under the same license as this one) to be
respected.  See \bhref{https://creativecommons.org/licenses/by-sa/4.0}{creativecommons.org/licenses/by-sa/4.0} for all the details.


This version: \timestamp.

\vskip2mm
\hfill\begin{tabular}{l}Jonathan A.~ Poritz\\
Spring Semester, 2021\\
Pueblo, CO, USA
\end{tabular}

\setcounter{tocdepth}{3}
\makeatletter
\def\l@subsection{\@tocline{2}{0pt}{2.5pc}{5pc}{}}
\makeatother
\tableofcontents

\begin{preface}
  \chapter*{Preface}\label{preface}

  Many children want to keep secrets.
  
  Lovers on opposite sides of the globe want to whisper sweet nothings to each
  other over an international telephone system whose wires and fiber optic
  cables run under neighborhoods, city streets, fields, and forests, or over
  mountain passes and on deep sea beds.

  Continent-spanning empires need to store secrets and issue commands to distant
  government agents and agencies which cannot be modified in transit from the
  imperial center to its far-flung agents.

  Consumers want to buy goods from merchants in other time zones, giving their
  credit card numbers to those merchants in messages over the open Internet --
  which is, without some system for hiding the contents of those messages,
  about as safe as writing them on the sides of long-haul trucks as they go by
  on the highway.

  Everyone needs a little cryptology.

  The problem with crypto (as we shall call cryptology in this book) is that
  it has a reputation of being very hard and mysterious, as well as very easy
  to get wrong.  While there are aspects of crypto that are connected to quite
  modern and complex theories -- such as number theory, an old and deep
  branch of mathematics; complexity theory, a new(er) and subtle branch of
  computer science; and even quantum computation, a quite new wrinkle on a
  100 year-old version of physics which is famously counter-intuitive -- that
  are not particularly friendly to the novice, much of the over-all framing of
  crypto is perfectly easy to comprehend and to use.

  We contend, further, that this straightforward comprehension of the important
  basics of cryptology is most easily acquired by actually \textit{working with
  cryptographic primitives}, by doing actual coding projects to implement, or
  use others' implementations of, basic cryptographic ideas.

  That is the subject of this book.

  This version uses \Python\ and some standard cryptographic libraries in
  \Python\ to explore these cryptological ideas.  It should be accessible to
  students with a solid basic comfort level with \Python\ -- but could also be
  used as a way to solidify \Python\ knowledge in more beginning users of that
  language, particularly if those beginners had a friendly instructor or peers
  with whom to collaborate.
  
\end{preface}

\mainmatter

\chapter{Preliminaries}\label{chap:preliminaries}

Here are some Greek roots:
\begin{description}
\item[{\it kryptos}, $\kappa\rho\upsilon\pi\tau o\varsigma$] secret, hidden
\index{kryptos [$\kappa\rho\upsilon\pi\tau o\varsigma$, Greek root]}
\item[{\it logos}, $\lambda\acute{o}\gamma o\varsigma$] word, study, speech
\index{logos [$\lambda\acute{o}\gamma o\varsigma$, Greek root]}
\item[{\it graph}, $\gamma\rho\acute{\alpha}\varphi\omega$] write, written
\index{graph [$\gamma\rho\acute{\alpha}\varphi\omega$, Greek root]}
\item[{\it analysis}, $\alpha\nu\acute{\alpha}\lambda\upsilon\eta$] analysis
\index{analysis [$\alpha\nu\acute{\alpha}\lambda\upsilon\eta$, Greek root]}
\end{description}

From these (and others), modern (technical) English gets the words
\begin{description}
\item[{\it cryptosystem}] a set of algorithms for protecting secrets, for
  hiding information so that only the intended persons have access to it
\index{cryptosystem}
\item[{\it cryptography}] work done to make cryptosystems
\index{cryptography}
\item[{\it cryptanalysis}] work done to circumvent the protections of
\index{cryptanalysis}
cryptosystems -- to ``crack'' a cryptosystem
\item[{\it cryptology}] the combination of cryptography and cryptanalysis,
often abbreviated simply to {\it\ix{crypto}}.
\index{cryptology}
\end{description}

Beware that {\it cryptography} is widely (but inappropriately!) used as a
synecdoche for {\it cryptology}.  We will use these words more carefully,
except when the differences between the words is not so important, in which
case we will use the word \textit{\ix{crypto}} as short for whichever
of cryptology, cryptography, or cryptanalysis is most appropriate\footnote{Note
  this use of ``crypto'' conflicts a little with a silly modern usage of that
  word as short for \textit{\ix{cryptocurrency}}.  We will return to that
  topic much later, when we talk about \textit{\ix{blockchains}}.}

\vfill
\pagebreak
\section{Some speculative history}
\label{sec:Ssh}

Perhaps there was a form of deception that preceded language -- certainly many
a house pet has feigned innocence despite the clear evidence of involvement in
stealing treats.  And even apiologists may not know if some lazy bees make up
a story about a long excursion to a new flower patch when their Queen demands
an accounting.

But among {\it homo sapiens}, probably as soon as there was language, there
was lying.  Of course, when two humans are face to face, both parties have
some control, such as: the listener can make an attempt to evaluate the
trustworthiness of speaker, they can both form their own judgments of the
other's identity and therefore choose what they wish to share with each
other, and the words of the speaker pass directly from their lips to the
listener's ears without the possibility of change of meaning in flight
(absent considerations of ambient noise and so on).

A great deal changed with the invention of writing more than 5000 years ago.
Words frozen in physical form, and the ideas they represent, can be taken and
shared with a wide range of parties other than those with whom the original
author wanted to communicate.  In addition, if an author is not able to hand
her work directly to the intended reader and instead the written words are
out in the world on their own for a while, then both intended communicants can
no longer be sure that the other is who the writing claims them to be nor
that the writing remains the unchanged symbols that the other party originally
set down.

Let us formalize some of these issues of {\it\ix{information security}} (as
it is called now), in the context of a message to be sent from someone named
{\it Alice} to someone named {\it Bob}.  The role of the possibly disruptive
and overly intrusive environment is played in our little drama by {\it Eve}.
(Traditionally one skips directly to a character whose name starts with {\it
E} to symbolize both the {\it environment} and also someone who is
potentially an {\it eavesdropper}\footnote{{\it Eavesdropper} apparently comes
from the Old English {\it\ix{yfesdrype}}, meaning literally {\it one who stands
on the eavesdrop} [ground where water drips from the eaves of the roof]
{\it to listen to conversations inside a house.}}.)  Note that another way to
think of what Eve is doing is listening to what is going by on some
unfortunately (maybe unintentionally) public \textit{communications channel}
that Alice and Bob are using.

Here is some basic terminology:
\begin{definition}\label{def:confidentiality}
\textbf{Confidentiality}\index{confidentiality} means that only the intended
recipient can extract the content of the message -- Alice wants only Bob to
get her message and not Eve, no matter if she listens on the eavesdrop or
intercepts the message as it travels in some form from Alice to Bob.
\end{definition}

\begin{definition}\label{def:integrity}
Message \textbf{\ix{integrity}} means that the recipient can be sure the
message was not altered -- Bob wants to know that what he gets is what Alice
wrote, not what the mischievous Eve intended to change it into.
\end{definition}

\begin{definition}\label{def:authentication}
Sender \textbf{\ix{authentication}} means that the recipient can determine
from the message the identity of the sender -- Bob wants to be sure this
message did in fact originate with Alice.
\end{definition}

\begin{definition}\label{def:non-repudiation}
Sender \textbf{\ix{non-repudiation}} means that the sender should not be able
to deny sending that message -- Bob wants to be able to hold Alice to her
promises.
\end{definition}
Note that Alice and Bob may actually be the same person sending a message from
a past self to their future self.  For example, someone may want to keep
records which must be {\it confidential} and whose {\it integrity} must be
reliable, even if there is a break-in to the site keeping those records.

In fact, information storage can always be thought of, in this way, as an
attempted communication from the past to the future via a channel that may
unexpectedly become public if, for example, your laptop is stolen or someone
breaks into your business and steals the hard drive from your server.  Unless
you can be absolutely sure that in all possible futures, no bad actor will
ever possibly have physical access to your computer, it's always a good idea
to encrypt all of your data on your personal devices!


Before we go on, a few more technical terms:
\begin{definition}
\label{def:clearplaintext}
\index{cleartext}\index{plaintext}
The message that Alice wishes to send to Bob, in its actual original form is
called the {\bf plaintext}.
\end{definition}
\begin{definition}\label{def:encryptioncipher}
\index{encryption}\index{cipher}
An algorithm that Alice uses to transform (scramble, obfuscate) the plaintext
into a form that will remain confidential even if observed by Eve while in
flight is called a {\bf cipher}.  We also say that Alice {\bf encrypts} the
(plaintext) message.
\end{definition}
\begin{definition}\label{def:ciphertext}
\index{ciphertext}
The encrypted form of a plaintext message is called the {\bf ciphertext}.
\end{definition}
\begin{definition}\label{def:decrypt}
\index{cipheterxt}
When Bob receives the ciphertext, he applies another algorithm to
\textbf{decrypt}\index{decryption}
it and recover the plaintext.
\end{definition}

\begin{center}
  {\large\textbf{Basic crypto terminology, graphically:}}\\
  \ \\
  \begin{tabular}{|c|c|c|}
    \hline
    \textbf{Alice}  &\ \ on public network/channel\ \ & \textbf{Bob} \\
    & (where \textbf{Eve} is watching) & \\
    \hline
    \ \ \ {\bf plaintext}/{\bf cleartext}\ \  & & \\
    message $m$  & & \\
    {\bf encrypts} $m$ to $c$& &\\
    transmits $c$ & \ \quad$\rightarrowtail\ \ \ ${\bf ciphertext}\ $c\ \ \ \rightarrowtail$\quad\  & receives $c$\\
    & & {\bf decrypts} $c$ to\\
    & &\ \  recover plaintext $m$\ \ \ \\
    \hline
  \end{tabular}\\
  \ \\
\end{center}

\vskip4mm Hundreds of years of experience with cryptology have shown, again
and again, that a cryptosystem which one person dreams up, thinking they have
invented a system with wonderfully strong security, may easily fall to
cryptanalysis done by someone else.  So it has gradually come to be
understood that the best way to make sure one is using a really solid
cryptosystem is to share the algorithms widely and publicly, so that others
in the community can try to break them.  As is said in the
FLOSS\footnote{``FLOSS''=''Free/Libre/Open-Source Software, '' a better term
  than just ``open source''} community: \textit{with enough eyes, all bugs are
  shallow}.  Therefore, we should only trust a cryptosystem if its security
remains strong even after everyone has tried their best to break it!

If the algorithm is public, how does it provide any security at all?  The
answer is that the algorithm may be public, but it is designed to take as
input one more piece of information, beyond just the plaintext to encrypt or
the ciphertext to decrypt:

\begin{definition}\label{def:key}
\index{key}
Additional information (some of which is) used in encryption and (some of)
which is necessary for successful decryption is called a {\bf key}.
\end{definition}

Think of a \ix{key} as something that Alice uses to lock her message in
a box, the box being the message as it is transmitted over a public network and
even possibly seen by Eve, and then used by Bob to unlock the box and find out
what the actual message was that Alice wanted to send.  Clearly, the keys must
be kept carefully secret for the cryptosystem to do its job of protecting
Alice and Bob's communications from the eavesdropping Eve!

This idea -- that the security of a cryptosystem should be based on the
secrecy of the key but not of the algorithm -- has come to be called
\textbf{\ix{Kerckhoff's Principle}}, after a set of cryptosystem design ideas
written down in 1883 by a French military cryptographer.  The opposite of a
system made with Kerckhoff's Principle in mind is one whose algorithms are
simply kept secret, and in which it is very foolish to place any trust: such
weak systems are said to reply upon the ill-advised
\textbf{\ix{security through obscurity}} paradigm.

\vskip5mm
\begin{AZtcb}[label=az:SSHbasic]{}{}
Does all of this make sense?  What was new or interesting, or what was old and uninteresting?
\end{AZtcb}
\vskip5mm
\begin{AZtcb}[label=az:SSHAliceandBob]{}{}
  Can you think of an example not mentioned above where the terms like
  \textbf{confidentiality}, \textbf{integrity}, \textbf{authentication}, and/or
  \textbf{non-repudiation} could be used to describe something you've read about
  or experienced?  Or else, can you think of a situation where these kinds of
  information security concepts apply to some version of \textbf{Alice},
  \textbf{Bob}, \textbf{Eve}, and a \textbf{public channel}? -- if so, say
  what that situation was and what corresponded to each of those characters.
\end{AZtcb}

\vfill
\pagebreak
\section{The Caesar cipher and its variants}\label{sec:TCcaiv}

A cryptosystem which dates to ancient times was supposedly used by
\ix{Julius Caesar}.
\begin{definition}
\label{def:caesarcipher}
\index{Caesar cipher!definition}
Alice takes her message, removes all spaces and punctuation, and puts it all
in one case (maybe lower case).  Then she moves each letter $k$ places
down the alphabet, wrapping around from \textbf{z} to \textbf{a} if necessary,
where $k$ is a fixed whole number known to both Alice and Bob but no one else,
called the {\bf key}.  (Often the ciphertext is written entirely in upper case,
so it is easier to tell plaintext from ciphertext.)

To decrypt, Bob simply moves each letter $k$ places earlier in the alphabet,
wrapping past \textbf{A} to \textbf{Z} if necessary: in other words, Bob
\textit{encrypts} the ciphertext with key $-k$ to get the plaintext.

This is called the \textbf{\ix{Caesar cryptosystem}} or {\bf Caesar cipher}.
\end{definition}

Apparently \ix{Julius Caesar} usually used the key value $k=3$.
His nephew Octavian\index{Octavian (Augustus)}, who later became the emperor
Augustus\index{Augustus (Octavian)}, liked to use $k=-1$.

When using what is called the Latin alphabet (which is not what was used in
ancient Rome, though!), with its 26 letters, there is one particularly nice key
value: 13.  The nice thing about that value is encryption and decryption are
exactly the same transformation.  In modern times, this transformation is
called \textbf{\ix{ROT13}}, and it has a small role in the modern history
of the Internet.  In particular, posts on early chat rooms and bulletin boards
would sometimes want to have a bit of content that should not be automatically
available to anyone who looks at the post, but would be there for the determined
reader (such as, for example, a spoiler in a review of some popular new game,
book, or film).  These were often included in the post, but only after they
had been run through ROT13.

A few commercial products used ROT13 for actual security, despite it actually
being completely insecure, such as certain parts of some versions of the
Windows operating system.

\vskip5mm
\begin{AZtcb}[label=az:Caesar]{}{}
Have you heard of the Caesar cipher before?  Is it clear to you how to use it?
\end{AZtcb}

\vskip1cm
\subsection{Keys only matter ``mod 26''}\label{ssec:TCcaiv_komm26}
Notice that if Alice uses the Caesar cipher and key $k_{\rm Alice}=1$, her
encryption does exactly the same thing as Ann who was using Caesar with key
$k_{\rm Ann}=27$, because of that part of the definition of the Caesar
cryptosystem which says ``wrapping around from \textbf{z} to \textbf{a}'':
Ann will always go all the way around the alphabet once, but then end up at
the same place Alice will.  The reason for this is that $27=26+1$, and
encrypting with $27$ goes around the alphabet once -- from the $26$ -- and
then goes one more step.  The same thing would happen if Ann used the key
$k_{\rm Ann}=53=2*26+1$, in that Ann's encryption process would go around the
alphabet -- twice, in this case, from the $2*26$ -- and then end up at the
same place as Alice's.

In fact, if difference between Alice's and Ann's key is any number of $26$s,
then their encryptions will look exactly the same!  Mathematicians have a
bit of terminology and notation for this:
\begin{definition}\label{def:modulo}
  \index{modulo}\index{mod}
  Suppose $a$, $b$, and $n$ are three whole numbers.  Then we say that
  \textbf{$a$ is equal to $b$ modulo $n$} if $a-b$ is a multiple of $n$; that
  is, if there is some other whole number $k$ such that $a-b=k*n$.  The
  notation for that is
  $$
  a\cong b\pmod{n}
  $$
\end{definition}

\begin{example}
  As we just noticed, $1\cong27\pmod{26}$.
\end{example}
\begin{example}
  ROT13 was so convenient because doing it twice has the effect of doing
  nothing, because
  $$
  13+13\cong0\pmod{26}
  $$
  Or, thought of another way, since
  $$
  -13\cong13\pmod{26}
  $$
  ROT3 encryption (Caesar with key $13$) is exactly the same thing as ROT13
  decryption (Caesar with key $-13$).
\end{example}

\vskip2mm
\begin{AZtcb}[label=az:mod26]{}{}
Does all of this make sense?  What was new or interesting, or what was old and
uninteresting?\\
If you feel comfortable with this new terminology and notation, try to
answer the following question: If you have a whole number $x$ and you know
that $x\cong0\pmod{2}$, what would be a more common way of talking about
that number?  \textit{I.e.,} you would say that ``$x$ is
\underline{\hphantom{XXX}}.''
\end{AZtcb}
\vskip2mm

Computer languages usually have a way to work with numbers mod $n$.  For
example, \Python\ has a built-in arithmetic operation which is useful
here: \code{a\%n} gives the smallest non-negative whole number which
is equal to \code{a} mod \code{n}.

\begin{example}\label{eg:basicmodsinPy}
  From what we noticed above, in \Python
  
  \noindent\begin{codedisp}
    >>> 27%26
    1
  \end{codedisp}
  \\
  and\\[2mm]
  \noindent\begin{codedisp}
    >>> -13%26
    13
  \end{codedisp}
  
  \noindent Even more, we can use this operator to implement the Caesar cipher!

  First, notice that we can't just add a key to a letter, because the types
  don't work:

  \noindent\begin{codedisp}
    >>> 'a'+2
    Traceback (most recent call last):
      File "&lt;stdin>", line 1, in &lt;module>
    TypeError: must be str, not int
  \end{codedisp}

  So we must first convert a character to an \code{int} and then back to
  a character:\\
  \noindent\begin{codedisp}
    >>> chr(ord('a')+3)
    'c'
  \end{codedisp}
  
  Note that \code{ord()} takes a single character and converts it to an
  \code{int}, while \code{chr()} takes an \code{int} and
  converts it to a single character.  It's not so important what
  are the details of how that works, except to note that the encoding includes
  all of the lowercase letters, in alphabetical order, in one numerical block
  from the value \code{ord('a')} to the value \code{ord('z')}, and
  all of the uppercase letters, in alphabetical order, in another numerical
  block from \code{ord('A')} to \code{ord('Z')}.

  Actually, that's not going to work with a letter too close to the end of
  the alphabet, \textit{e.g.,}\\
  \noindent\begin{codedisp}
    >>> chr(ord('y')+3)
    '|'
  \end{codedisp}
  
  \noindent because it didn't ``wrap around the alphabet.''

  So how about if we take a character in a variable \code{x} and do the
  following:
  \begin{enumerate}
  \item make it into a number using \code{ord()}
  \item shift it so that it's in the range from \code{0} to
    \code{25} by subtracting \code{ord('a')}
  \item do the Caesar by adding the value \code{k}
  \item get it back in the range \code{0} to \code{25} by doing
    \code{\%26}
  \item get it in the range \code{ord('A')} to \code{ord('Z')}
    by adding \code{ord('A')}
  \item make it back into a letter using \code{chr()}
  \end{enumerate}
  \textit{E.g.,} if \code{x='y'} and \code{k=4} then we would get\\
  \noindent\begin{codedisp}
    >>> chr((ord(x)-ord('a')+k)%26+ord('A'))
    'C'
  \end{codedisp}
\end{example}

Let's now implement the Caesar cipher in \Python, in steps.  First, we should
clean up the plaintext string.

\vskip2mm
\begin{CTtcb}[label=ct:cleanstring]{}{}
  Write a \Python\ function which takes an input string and returns a string
  which is the same except all the non-letter characters have been removed
  and all the letters have been made to lower case.
\end{CTtcb}

\vskip2mm
It might help to know that you can loop through the characters of a string
\code{s} by doing\\
\noindent\begin{codedisp}
  for x in s:
\end{codedisp}

\noindent and you can build up a string \code{o} for output by starting
with\\
\noindent\begin{codedisp}
  o=''
\end{codedisp}

\noindent and then adding one or more characters in a string variable
\code{t} to the end of \code{o} by doing\\
\noindent\begin{codedisp}
  o=o+t
\end{codedisp}

Another, more ``Pythonic'' approach is probably to build up a list by the
construction\\
\noindent\begin{codedisp}
  [ c for c in s ]
\end{codedisp}

\noindent which just makes a list each of whose elements is a single character out of
the string \code{s}.  Note you can also do something to the characters
as you put them in the list, and you can add a condition to the looping part,
such as\\
\begin{codedisp}
  [ ord(c) for c in s if c.isalpha()]
\end{codedisp}

\noindent -- try it!

\vskip2mm
\begin{CTtcb}[label=ct:Caesarencrypt]{}{}
  \textbf{Caesar encryption:} write a \Python\ function
  \code{Caesar\_encrypt(s, k)} which takes an input string \code{s} --
  the plaintext -- and an int \code{k}and returns the ciphertext from
  that plaintext under the Caesar cipher with key \code{k}.

  For example, if you do\\
  \hphantom{XXX}\code{Caesar\_encrypt('All the animals at the zoo!', 3)}\\
  the output should be\\
  \hphantom{XXX}\code{'DOOWKHDQLPDOVDWWKHCRR'}.
\end{CTtcb}

\vskip2mm
\begin{CTtcb}[label=ct:Caesardecrypt]{}{}
  \textbf{Caesar decryption:} Write a \Python\ function
  \code{Caesar\_decrypt(s, k)} which takes an input string \code{s} --
  the ciphertext -- and an int \code{k} and returns the plaintext from
  that ciphertext under the Caesar cipher with key \code{k}.

  For example, if you do\\
  \hphantom{XXX}\code{Caesar\_decrypt('DOOWKHDQLPDOVDWWKHCRR', 3)}\\
  the output should be\\
  \hphantom{XXX}\code{'alltheanimalsatthezoo'}.

  You might want to do a sanity test on your input and return an error or a
  null string if the input is not a well-formed ciphertext, \textit{i.e.,} a
  string consisting only of uppercase letters.
\end{CTtcb}

\vskip1cm
\subsection{Modernizing the Caesar cipher}\label{ssec:TCcaiv_mtCc}
It seems unfortunate that the Caesar cipher, as we have used it, looses the
punctuation in the messages and case of the letters of the message.  One way
to get around this would be to imagine all of the letters of both cases and
all punctuation symbols to be part of a much bigger alphabet, and then to use
the same old Caesar with this much bigger alphabet, correspondingly using
\code{\%N}, where \code{N} is the new alphabet size, in place of the
\code{\%26} we were using before.

Technically, in \Pythonthree, strings are made of characters, and characters
are encoded using \textbf{Unicode}.  Unicode is a way of turning numbers,
represented by one, two, or four bytes, into many special symbols as well as
letters from many writing systems used around the world.

The first 128 symbols in Unicode, which therefore fit into one byte (in fact
with the highest-order bit being 0), are just the old ASCII encoding scheme,
dating back to 1963, for the English alphabet plus some additional punctuation,
symbols, and even non-printing symbols like ``EOF.''  The name of the encoding
scheme for the subset of Unicode which fits in 8 bits is ``UTF-8,'' which
includes all of the old ASCII code.

Full Unicode in two or four bytes includes many non-Latin alphabets (such as
Greek, Cyrillic, hangul, \textit{etc.}) and even non-alphabetic writing
systems like Chinese and Japanese (actually, part of Japanese is
non-alphabetic, called ``kanji,'' but Japanese also has two different writing
systems based on syllable sounds, called ``hiragana'' and ``katakana,'', each
with 49 symbols), with thousands of ideograms.

\vskip2mm
\begin{AZtcb}[label=az:unicode]{}{}
  Have you heard of Unicode?

  If not, you might also read, or at least skim,
  \bhref{https://en.wikipedia.org/wiki/Unicode}{the Wikipedia page about
    Unicode} and say what you think of it.

  Have you ever worked with Unicode in \Python?

  If so, what did you think of it?  If not, you might also read, or at least
  skim either the \Python\ documentation
  \bhref{https://docs.python.org/3/howto/unicode.html}{Unicode HOWTO} or
  the more detailed
  \bhref{https://realpython.com/python-encodings-guide/}{Unicode \& Character Encodings in Python: A Painless Guide} and say what you think about it.
\end{AZtcb}

\vskip2mm
\begin{BTtcb}[label=bt:generalizedCaesar]{}{}
  Implement in \Python\ a Caesar-style encryption and decryption which works
  for a different alphabet than English.  Maybe do Spanish (one extra letter:
  \~n) or German (four extra letters: \"a, \"o, \"u, ß)....

  \textbf{Or}, maybe implement Caesar with the English alphabet, but figure
  out some way to keep the punctuation as well.  It seems like it might be
  giving away too much information to leave the spaces and punctuation the
  same in the ciphertext as it was in the plaintext, but can you do something
  interesting with it?

  \textbf{Or}, maybe implement a Caesar-style cryptosystem which handles all
  of ASCII, or UTF-8, or all of Unicode!
\end{BTtcb}

\vfill
\pagebreak
\section{Cryptanalysis of the Caesar cipher}\label{sec:CotCc}

Let's think about cryptanalysis of the Caesar cipher; that is, let's figure
out how to get a plaintext back from a Caesar ciphertext when we don't know
the key.

The first thing we should notice is that, as we saw in
\S\ref{ssec:TCcaiv_komm26}, the key only matters ``up to mod 26.''  But every
possible whole number $k$ for a key is equal mod 26 to a whole number in the
range from $0$ to $25$: just try running\\
\begin{codedisp}
  for i in range(100):
    print(i\%26)
\end{codedisp}

\noindent to get a feel for what's happening.

So, effectively, there are only $26$ possible keys for a Caesar cipher!  In
fact, it would be pretty silly to use the key $k=0$, since then the ciphertext
would be exactly the same as the plaintext (well, without the non-letter
characters, and all in upper case).  So there are really only $25$ reasonable
Caesar cipher keys.  It seems like this kind of thing is important enough to
have its own name:
\begin{definition}
  \label{def:keyspace}
  \index{keyspace}
  The set of possible keys for some cryptosystem is called the \textbf{keyspace}
  of the cryptosystem.
\end{definition}
What we have just seen is that the keyspace of the Caesar cipher is just the
whole numbers from 1 to 25.  In \Python, it is the elements of the list
\code{range(1,25)}.

An enemy of Caesar's who intercepted a ciphertext of his and who wanted to know
what it said could assemble a team of $25$ literate people (maybe those were
hard to find at the time?) who could count (also hard?) and use them to make
a \textit{Caesar-cracking computer} as follows:
\begin{itemize}
\item[$\bullet$] each person would be assigned one of the numbers from 1 to
  25
\item[$\bullet$] each person would write out the Caesar-decryption of the
  intercepted ciphertext, using their assigned number as key
\item[$\bullet$] if one of them got something which looked like it was
  written in good Latin, they would shout ``Success!'' and read out their
  decryption
\end{itemize}

This would be a pretty fast and economical way to crack the Caesar cryptosystem
only \textbf{because the keyspace is so small}.  This kind of attack has a name:
\begin{definition}
  \label{def:bruteforce}
  An attempt to cryptanalyze a cryptosystem by trying all of the possible values
  of some parameter of the system (such as all possible keys or all possible
  messages) is called a \textbf{\ix{brute-force attack}}.
\end{definition}

\vskip5mm
\begin{AZtcb}[label=az:CCCbruteforce]{}{}
  Does all of this make sense?  What was new or interesting, or what was old and uninteresting?

  Can you think of an example of a \textbf{\ix{brute-force attack}} used in some
  information security context that you know about from other classes or
  other readings or just from your life?
\end{AZtcb}

\begin{CTtcb}[label=ct:BTCaesar]{}{}
  Write a \Python\ function \code{CaesarBF(s)} implementing a
  \ix{brute-force attack} on the Caesar cryptosystem.  Given an input
  ciphertext, it should try all possible keys for decryption and print
  out the attempted key and the corresponding decryption.

  \textit{E.g.,} the output of \code{CaesarBF('DOOWKHDQLPDOVDWWKHCRR')}
  should be\\
\begin{codedisp}
  1:   cnnvjgcpkocnucvvjgbqq
  2:   bmmuifbojnbmtbuuifapp
  3:   alltheanimalsatthezoo
  4:   zkksgdzmhlzkrzssgdynn
  5:   yjjrfcylgkyjqyrrfcxmm
  6:   xiiqebxkfjxipxqqebwll
  7:   whhpdawjeiwhowppdavkk
  8:   vggoczvidhvgnvooczujj
  9:   uffnbyuhcgufmunnbytii
  10:   teemaxtgbfteltmmaxshh
  11:   sddlzwsfaesdksllzwrgg
  12:   rcckyvrezdrcjrkkyvqff
  13:   qbbjxuqdycqbiqjjxupee
  14:   paaiwtpcxbpahpiiwtodd
  15:   ozzhvsobwaozgohhvsncc
  16:   nyygurnavznyfnggurmbb
  17:   mxxftqmzuymxemfftqlaa
  18:   lwwesplytxlwdleespkzz
  19:   kvvdrokxswkvckddrojyy
  20:   juucqnjwrvjubjccqnixx
  21:   ittbpmivquitaibbpmhww
  22:   hssaolhupthszhaaolgvv
  23:   grrznkgtosgrygzznkfuu
  24:   fqqymjfsnrfqxfyymjett
  25:   eppxliermqepwexxlidss
\end{codedisp}
\end{CTtcb}

\vskip2mm
That's all well and good, but we have a huge problem: human intervention is
required here, to pick out which possible decryption, in the
\ix{brute-force attack}, is the correct one!

For example, suppose bad actors invaded your organization's network and
encrypted all of your files with the Caesar cipher, but choosing a different
key for each one.  Your organization probably has hundreds of thousands of
files, and while any individual one could be easily decrypted, it would take
an insane number of person-hours to decrypt your whole network ... you might
be willing to pay a fairly large ransom to get all of your files back without
all that human life invested in brute-force\index{brute-force attack} decryption.

\vskip1cm
\subsection{Frequency analysis}\label{ssec:CotCc_Fa}

Let's think about how to automate the choice of the correct decryption in a
\ix{brute-force attack} on the Caesar cipher.

The key idea here is just the observational fact that \textit{the relative
  frequencies of different letters in English are relatively stable across
  almost all pieces of English text}.  In particular, in English, the most
common letter is usually ``e,'' the second most common is usually ``t,''
\textit{etc.}

This suggests an approach to detecting automatically which decryption in the
\ix{brute-force attack} is the correct one: declare victory when the brute-force
approach has found a possible decryption where the most common letter is ``e.''

\vskip2mm
\begin{CTtcb}[label=ct:freq_count]{}{}
  Write a \Python\ function \code{freq\_table(s)} which makes the
  \textit{\ix{frequency table}} for the letters of a string
  \code{s}.  That is, first clean up \code{s} by removing all
  non-letters and making all remaining letters be in the lower
  case. Then \code{freq\_table()} should returns a list of
  26 \code{int}s where the value at location \code{i} in this list
  tells how many times the letter \code{chr(i+ord('a'))}  occurred in
  the cleaned-up input string.

  For example, executing\\
  \code{freq\_table('alltheanimalsinthezoo')}\\
  should return the list\\
  \code{[3,0,0,0,2,0,0,2,2,0,0,3,1,2,2,0,0,0,1,2,0,0,0,0,0,1]}.
\end{CTtcb}

\vskip2mm
\begin{CTtcb}[label=ct:CaesarBF_findE]{}{}
  Write a \Python\ function \code{CaesarBF\_findE(s)} uses your previous
  \code{CaesarBF(s)} but only prints out the possible decryption if the
  letter ``e'' is the most frequent in the proposed cleartext.  That is, each
  time your function computes a possible cleartext, you should get the frequency
  table \code{freqs} from that string, using your \code{freq\_table()}
  function.  Then do the test \code{freqs[4]==max(freqs)} to see if the
  letter at index 4, which is ``e,'' has the maximum frequency.  Only if the
  test passes will you print out that possible cleartext.
\end{CTtcb}

\vskip2mm
Clearly, this strategy doesn't seem to work too well, because it would find that
the string \code{'teemaxtgbfteltmmaxshh'} from key \code{10} and
\code{'eppxliermqepwexxlidss'} from key \code{25} were both possible
decryptions of \code{'DOOWKHDQLPDOVDWWKHCRR'}, neither of which is correct!

The problem is that the single letter which is most frequent is too coarse a
piece of information about a string to be useful to determine whether the string
is in good English.  However, the entire frequency table does a much better
job.  Let's implement that in \Python\ now, in several steps.

\vskip2mm
\begin{CTtcb}[label=ct:rel_freq_count]{}{}
  Modify your \Python\ function \code{freq\_table(s)} to make one called
  \code{rel\_freq\_table(s)} which computes the
  \textit{\ix{relative frequency table}}\index{frequency table, relative} for
  an input string \code{s}: a table which computes the fraction of the
  letters in \code{s} which are each particular letter.  If the list
  computed by \code{freq\_table()} is \code{f}, then the relative
  version will have \code{float}s rather than \code{int}s, with values
  that are the values of \code{f} divided by \code{sum(f)} (or, what
  should be the same thing, divided by \code{len} of the input string).

  For example, executing \code{rel\_freq\_table('zbazb')}
  should return the list
  \code{[0.2,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,}
  \code{ 0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.4]}.
\end{CTtcb}
  
\vskip2mm
\begin{CTtcb}[label=ct:rel_freq_count_English]{}{}
  Run your function \code{rel\_freq\_table()} on some very long pieces of
  English text, to get the model relative frequency table of the English
  language.

  You might compare the values you get from what Wikipedia says should be
  the right table of relative frequencies in
  \bhref{https://en.wikipedia.org/wiki/Letter_frequency}{the article Letter Frequency}.  Did you get a similar answer?  If not, do you have a guess of why?
\end{CTtcb}

\vskip2mm
\begin{CTtcb}[label=ct:dist_rel_freq_tables]{}{}
  You will need, in a moment, a tool which computes the ``distance'' between
  two relative frequency tables.  Those tables are lists of numbers of length
  26.  Well, if you have a list of two numbers, you can think of those numbers
  as the coordinates in two-dimensional space.  If you have a list of three
  numbers, you can think of them as coordinates in three-dimensional space.
  So a list of 26 numbers could be thought of as the coordinates in
  26-dimensional space.   Weird, yes, but go with it....

  In two- or three-dimensions, the distance between two points is given by the
  square root of the sum of the squares of the differences between the
  coordinates.  That is, in two dimensions, the distance between two points
  with coordinates $(x_1,y_1)$ and $(x_2,y_2)$ is, by the
  \ix{Pythagorean Theorem}, given by the formula
  $\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$.  The same thing also works in three ... or
  in 26 dimensions: that's just the Pythagorean Theorem 25 times!

  So write a \Python\ function which takes as input two lists of numbers of
  the same length, say  they are \code{a} and \code{b}.   It should
  then take the first element of \code{a} minus the first element of
  \code{b} and square that difference.  It should add to that square the
  square of the difference of the second elements, and so on until all the
  elements are used up.  Finally, it should return the square root of that
  total, which will be the value of \code{freq\_table\_dist(a,b)}.
\end{CTtcb}

\vskip2mm
\begin{CTtcb}[label=ct:CaesarBF_rel_freqs]{}{}
  Now implement a \Python\ function \code{CaesarBF\_rel\_freq(s)} tries all
  possible Caesar decryptions of the input ciphertext string \code{(s)},
  and picks the one whose relative frequency table is least different from
  the standard relative frequency table of English which you just found.

  Here are the steps: do the \code{CaesarBF(s)} approach from before, and
  compute the relative frequency table for each possible decryption.  Now
  compute the ``frequency table distance,'' in the sense of the previous
  coding task, between the relative frequency table for this possible
  decryption and the standard relative frequency table for English.

  When you're done, find the smallest distance of all those possible decryptions
  and announce that one as the best guess of the real decryption of the input
  ciphertext.
\end{CTtcb}

\vskip4mm
\begin{BTtcb}[label=bt:stresstestCaesarBF_rel_freqs]{}{}
  Now let's stress-test the brute force\index{brute-force attack} Caesar cipher
  cracker which uses frequency analysis.

  \vskip2mm
  First, try taking a big piece of text in another language, encrypt it
  with the Caesar cipher and some random key, and then use your function
  \code{CaesarBF\_rel\_freq(s)} to try to decrypt it automatically.  For
  example, you might take some of \bhref{https://www.gutenberg.org/files/2000/2000-0.txt}{the Spanish text of the famous novel Don Quixote} or simply
  cut-and-paste from
  \bhref{https://www.lemonde.fr/}{the French newspaper \textit{Le Monde}} or
  \bhref{https://www.deutschetageszeitung.de/}{the German newspaper \textit{Deutsche Tageszeitung}}. 
\textbf{Note:} for other languages, you may have an issue
  with the alphabet!  Letters with accents may mess up your constructions in
  \Python\ which assume the alphabet will be sequentially ordered from 0 to 25
  when you take each letter \code{c} and do \code{ord(c)-ord('a')}.
  Figure out how to handle this situation (probably by turning each special
  letter like into a letter in the English alphabet (like just make  ``\~{n}''
  into a plain ``n'').

  \vskip2mm
  Or you could try decrypting a text which was originally in Latin, like
  \bhref{https://www.gutenberg.org/cache/epub/28233/pg28233.txt}{the original
  Latin text of Isaac Newton's famous \textit{Philosophiae Naturalis Principia}}
  \bhref{https://www.gutenberg.org/cache/epub/28233/pg28233.txt}{\textit{Mathematica}}.

  \vskip2mm
  Another thing to do would be to try some very unusual text, but in English.
  For example, a man named Ernest Wright published a book called \textit{Gadsby}
  in 1939 which did not have the letter ``e'' anywhere in it.  Since ``e'' is
  the most common letter in normal English, the relative letter frequencies in
  this novel must be quite different from those in normal English.  Try
  encrypting and then automatically decrypting some of \bhref{https://www.gutenberg.org/cache/epub/47342/pg47342.txt}{the text of
  \textit{Gadsby}} (but make sure you go down far enough in that file to get
  to the text of the novel: the introductory material does have the letter
  ``e'').
\end{BTtcb}

\vfill
\pagebreak
\section{Defending Caesar against frequency analysis: Vigen\`ere
and the one-time pad}
\label{sec:DCafaVatotp}
\index{pig, yellow}

Sometimes a very short message is very important: ``yes'' or ``no'' is a big
difference in many situations!  But frequency analysis attacks on the Caesar
cipher depend upon having a relative frequency table to compare to the relative
frequency table of English ... and without a long enough enough ciphertext
string, there won't be much of a frequency table at all.

There must be some sort of threshold $k$ such that when a ciphertext string
has length $k$ or less, the relative frequency table doesn't give enough
information to do successful cryptanalysis.
There should also be another threshold $K$ such that when a ciphertext string
has length of $K$ or more, the cryptanalysis of the Caesar cipher using
relative frequency tables usually works.

For messages of length between $k$ and $K$, presumably, sometimes the approach
to cryptanalysis based on relative frequency tables is successful, and
sometimes not.

\vskip1mm
\begin{BTtcb}[label=bt:crack_Caesar_diff_sizes]{}{}
 Let's try to figure out what those thresholds $k$ and $K$ are.

 Do a big loop as some number \code{l} goes from 1 to 150 (or so).  For
 each value of \code{l}, you are going to figure out how often your
 relative frequency table-based Caesar cracker \code{CaesarBF\_rel\_freq}
 is successful on strings of length \code{l}.

 Make a very long string \code{big\_string} with some text. You probably
 want to take all of the non-letters out of \code{big\_string} and make
 all of the letters lower case.

 Now make a loop to try decrypting maybe 100 randomly chosen strings from
 \code{big\_string}.  Each time through the loop, pick a random substring
 from \code{big\_string} of length \code{l} -- the way to do this
 is to do\\
 \hphantom{XXX}\code{from random import *}\\
 once near the beginning of your program, then in this loop set\\
 \hphantom{XXX}\code{rand\_start = randint(0,len(big\_string)-l)}\\
 to be the random starting point for the substring, and\\
 \hphantom{XXX}\code{rand\_cleartext = big\_string[rand\_start:rand\_start+l]}\\
 to be the corresponding substring of length \code{l}.

 Now pick a random Caesar key \code{k=randint(1,26)}, encrypt
 \code{rand\_cleartext} to \code{rand\_ciphertext} with that key, and
 try your relative frequency table-based Caesar cracker on
 \code{rand\_ciphertext}.  If its proposed decryption equals
 \code{rand\_cleartext}, count that as a success.  If not, count it as a
 failure.

 See how many times out of the 100 (\textit{i.e.}, the percentage) in this
 inner loop you got success.
 
 Finishing the outer loop, you should now have a list of success percentages
 for each possible string length from 1 to 150, maybe in a list
 \code{successes}.

 Plot that list against the numbers from 1 to 150.  This can be done by first
 getting the plotting package with \code{import matplotlib.pyplot as plt},
 then making the plot with \code{plt.plot(x,successes)} where
 \code{x=[i+1 for i in range(149)]}.  You will need also to run
 \code{plt.show()} to display the plot.
\end{BTtcb}

The way to prevent relative frequency table-based attacks on the Caesar cipher
is to only use it to encrypt short messages (less than that threshold $k$ we
just mentioned).  This is a problem if it is important to encrypt a longer
message.

The approach to use with longer messages is simply to change the Caesar cipher
key frequently, so that not all that much cleartext is encrypted with each
particular key value.  For example, to make the string half as long, so that
relative frequency table methods are only half as good, we could use two keys
$a$ and $b$, and encrypt the first half of the message with Caesar under the
key $a$ and the second half with Caesar under key $b$.

Historically, this approach was implemented in a slightly different way: rather
than using $a$ for the first half of the message and $b$ for the second half,
people used $a$ for the letters in the first, third, fifth, \textit{etc.},
positions in the message, and $b$ for the letter in the second, fourth, sixth,
\textit{etc.} positions.

To cut the message pieces down even more, one can use even more keys than just
two.  There is a name for this cryptosystem:
\begin{definition}\label{def:vigenere}\index{Vigenere cryptosystem}
Fix $\ell$ numbers $k_1,k_2,\dots,k_\ell$.  The \textbf{Vigenere cryptosystem}
does encryption as follows: given a cleartext $c$, encrypt the first letter
of $c$ using the Caesar cipher with key $k_1$, the second letter of $c$ using
Caesar with key $k_2$, \textit{etc.}  When all of the $\ell$ key values have
bee n used, start again with $k_1$ for the next letter, then
$k_2$, \textit{etc.}  Vigen\`ere decryption works in the same way, except
Caesar decryption is used at each step.
\end{definition}

For example, the Vigen\`ere encryption of ``All the animals in the zoo'' with
three keys $3, 20, 4$ is ``DFPWBIDHMPUPVCRWBICIS,'' since
\begin{itemize}
\item[$\bullet$] 3 characters after ``a'' in the alphabet is ``D,''
\item[$\bullet$] 20 characters after ``l'' in the alphabet, wrapping around to
the beginning of the alphabet when falling off the end, is ``F,''
\item[$\bullet$] 4 characters after ``l'' is ``P,''
\item[$\bullet$] 3 characters after ``t'' is ``W,''
\item[$\bullet$] 20 characters after ``h'' in the alphabet, wrapping around to
the beginning of the alphabet when falling off the end, is ``B,''
\item[$\bullet$]  \textit{etc.}
\end{itemize}

Notice that we have achieved the goal of messing up frequency analysis
approaches to breaking our cryptosystem: for example, the repeated letter ``l''
in the cleartext word ``all'' has been encrypted into the two different letters
``F'' and ``P'' -- but the ``l'' later in the cleartext, in the word ``animal,''
has also been encrypted to ``P'' ... the frequency tables have been totally
scrambled!  In fact, we can see that by looking at the relative frequency
charts of the cleartext
\begin{figure}[H]
 \centering
 \includegraphics[height=6.5cm]{all_the_animals_freq.eps}
 \label{fig:all_the_animals_freq}
\end{figure}
\vskip-4mm\noindent and for the ciphertext from Vigen\`ere encryption with keys $3, 20, 4$
\begin{figure}[H]
 \centering
 \includegraphics[height=6.5cm]{vig_all_the_animals_freq.eps}
 \label{fig:vig_all_the_animals_freq}
\end{figure}
\vskip-4mm\noindent which looks completely different!  Contrast this with the relative
frequency chart for a Caesar encryption (with key $10$) of the same cleartext
\begin{figure}[H]
 \centering
 \includegraphics[height=6.5cm]{caesar10_all_the_animals_freq.eps}
 \label{fig:caesar10_all_the_animals_freq}
\end{figure}
\vskip-4mm\noindent which looks like the relative frequency chart of the original
cleartext, shifted horizontally.

\vskip5mm
\begin{AZtcb}[label=az:Vigenere]{}{}
  Does all of this make sense?  What was new or interesting, or what was old and uninteresting?  Do you feel like you understand the Vigen\`ere cryptosystem?
\end{AZtcb}

\vskip2mm
\begin{AZtcb}[label=az:Vigenerekeys]{}{}
  To show you understand Vigen\`ere, can you say what the keyspace is for
  a the Vigen\`ere cryptosystem when it uses $\ell$ key values?  And how big
  is that keyspace?  (How big it is will give us some information about how
  hard it is to do a \ix{brute-force attack} on this cryptosystem.)
\end{AZtcb}

\vskip2mm
\begin{CTtcb}[label=ct:Vigenere]{}{}
 Write a \Python\ function \code{Vigenere\_encrypt(s, k)} which takes
 a cleartext \code{s} and list \code{k} of key values and does
 Vigen\`ere encryption.

 Likewise implement a \Python\ function \code{Vigenere\_decrypt(s, k)}
 which does the decryption for ciphertext \code{s} and list \code{k}
 of key values.
\end{CTtcb}

\vskip3mm
Using the Vigen\`ere cipher with $\ell$ keys basically divides the cleartext
into $\ell$ different pieces and uses the Caesar cipher on each of these
different pieces, each time with a different key.  As long as these pieces are
sufficiently long, we can use our automated Caesar cipher cracker based on
relative frequency counts on each piece separately, figure out what the
separate Caesar keys are, and then do Vigen\`ere decryption with those $\ell$
keys we've figured out.

Notice that the $\ell$ pieces of the cleartext into which the Vigen\`ere
cryptosystem are all the same size, that being \code{len(s)}${}/\ell$ if
the cleartext is \code{s}.  Since an attack on the Vigen\`ere cryptosystem
is based on relative frequency-based attacks on the Caesar ciphers of those
pieces, and such relative frequency-based attacks only work if there is enough
data to make a good relative frequency table, if \code{len(s)}${}/\ell$ is
a small number, then the attack will fail.

In particular, if $\ell={}$\code{len(s)} then those $\ell$ pieces will have
only one character in them and relative frequency-based attacks will fail
miserably.  In other words, if you use a Vigen\`ere cryptosystem with $\ell$
keys on a cleartext of length $\ell$, then it is perfectly secure!  This is
so important that this cryptosystem is worth giving its own name:
\begin{definition}\label{def:onetimepad}\index{one-time pad}
A cryptosystem which is Vigen\`ere where there are as many keys as letters in
the cleartext is called a \textbf{one-time pad cryptosystem}, and the
\textbf{pad} in this cryptosystem is the name used for the collection of all
of those Vigen\`ere keys.
\end{definition}
It is a very important thing when using a one-time pad never to reuse the
pad -- that's why it's called a \textit{one-time} pad -- because if Eve guesses
that the pad has been reused, she can crack all of the messages which were sent
with that pad.  We will not discuss here how that attack on encryption with a
reused one-time pad works, but suffice it to say that the attack is based,
again, on frequency analysis.

One final note about one-time pads: typically, when using a one-time pad, the
keys are picked purely randomly.  The advantage of doing that is that there is
no way Eve can predict what the keys in the pad might be, even if she knows
Alice and Bob very well.  With a randomly chosen one-time pad, this cryptosystem
is called \textit{\ix{information theoretically secure}}, meaning that is
secure no matter how much computation power Eve can throw at the problem.

\vskip2mm
\begin{AZtcb}[label=az:onetimepad]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting?  Do you feel like you understand how one-time pads work?
\end{AZtcb}

\vskip2mm
\begin{CTtcb}[label=ct:OTPkeygen]{}{}
 Write a \Python\ function \code{OTP\_keygen(n)} which generates a one-time
 pad of size \code{n}.  As we said above, it's best if these pads are as
 random as possible, so you might want to do\\
 \hphantom{XXX}\code{from random import *}\\
 and then use the command \code{randint(a,b)} which returns a random
 integer in the range \code{a} to \code{b} (including both endpoints,
 which is unusual in {\Python}!).

 As an example of using your new \code{OTP\_keygen(n)}, send your instructor
 an email with a one-time pad of at least 100 elements.
\end{CTtcb}

\vskip2mm
\begin{CTtcb}[label=ct:OTPencrypt]{}{}
 Write a \Python\ function \code{OTP\_encrypt(s,k)} which takes
 a cleartext \code{s} and one-time pad \code{k} and does the
 encryption.

 Also write a \Python\ function \code{OTP\_decrypt(s,k)} which takes
 a ciphertext \code{s} and one-time pad \code{k} and does the
 decryption.

 As an example of using your new \code{OTP\_encrypt(s,k)}, send your
 instructor an email with your first \textbf{Reading Response} from the course,
 but encrypted using that one-time pad you sent for Coding Task
 \ref{ct:OTPkeygen}.  (If that \textbf{Reading Response} was longer than 100
 characters, you will have to truncate it to the first 100 characters so that
 you have enough one-time pad to do the encryption.)
\end{CTtcb}

\vskip2mm
\begin{BTtcb}[label=bt:OTPkeygen_better_rand]{}{}
 Since the quality of the randomness in a one-time pad can actually matter if
 you plan on encrypting very sensitive data, you might consider using a more
 sophisticated random number generator than the basic \code{randint(a,b)}
 from the \code{random} package ... which is fine for many uses, but maybe
 not good enough if you are trying to keep a large document secret from a
 powerful adversary.

 \Python\ has a function \code{urandom} in the package \code{os}
 which generates much stronger randomness.  Unfortunately, it returns just a
 string of random bytes, which you need to convert to \code{int}s by
 using in the {\Python} function \code{unpack} in the package
 \code{struct}.  \bhref{https://pynative.com/cryptographically-secure-random-data-in-python/}{Here is a web page which shows how to use these
 two functions}.

 Write a \Python\ function \code{OTP\_keygenCS(n)} which generates a
 one-time pad of size \code{n} with
 \textit{cryptographically secure randomness}.
\end{BTtcb}

\vskip2mm
\begin{CTtcb}[label=ct:OTPkeyfinder]{}{}
 Write a \Python\ function \code{OTP\_key\_finder(s, t)} which takes
 a string \code{s} consisting only of lower case letters and string
 \code{t} consisting only of upper case letters, where \code{len(s)}
 is the same as \code{len(t)} and computes what must have been the
 one-time pad which was used to get \code{t} as the ciphertext from
 \code{s} using the one-time pad cryptosystem.

 The fact that you can do this means that when Eve sees a ciphertext from
 a one-time pad cryptosystem, she cannot deduce anything about the original
 cleartext other than its length.  This is why this cryptosystem is information
 theoretically secure.

 \textit{Hint:} If you're looking at a letter \code{x} of cleartext and
 a letter \code{y} of ciphertext and wondering which number \code{k}
 in a one-time pad key could have encrypted \code{x} to \code{y},
 you're really asking the question ``what value of \code{k} makes\\
 \hphantom{XXX}\code{chr((ord(x)-ord('a')+k)\%26+ord('A'))==y}\\
 be true?''  Solving this
 for \code{k} would give one answer as\\
 \hphantom{XXX}\code{k=ord(y)-ord('A')-ord(x)+ord('a')}.
\end{CTtcb}

\begin{BTtcb}[label=bt:crack_vigenere_example]{}{}
 Suppose we somehow know that the following string is the Vigen\`ere encryption
 of some English cleartext with a Vigen\`ere cryptosystem having $\ell=2$
 keys:\\
 {\tt WUZHEGJUFPRQJFFXEWIBDHEOVQUPVBFXIHRUJLYDMHTRDHKRSXIBTDVV\\
      RUERKWFSIDZVVKZPKKVHMLCWYDKPVQURCLMHJDWWVUKKVPKKVJFRULJR\\
      WWZQKHIUWGNLKKKKVLIEFQVVJRCHKLKEVZZWYFRHJDIWYHERSOVEIXKX\\
      JKRWYWFOUBFXTDVVRUNDJDDEZWZRLVZIZWNHIHJRZWNDJDXUZHMRLVWD\\
      LOKDEGXUZHMRLVCBYDKKTDVVRURQJZVUVGZWYHIHLQUHIOVDMHFISULW\\
      LVRQUWYHIHJWWRIEIXKXJLJDEKFQFURECHDDEVFDIHKKVBROCDCOYRER\\
      IDSOVPVQTRDHZWFVGHRNZQTDVVRUJILQVUROYHNDJPPIILVQUIRLKKWX\\
      CDEGAXJWKRDHSXKEIXKXJVRBJKVZRVRPSLKLFXJDEGSULWLVZVRQYRER\\
      IDSOVPRQYHYDKKSUFXXKKPRQPFRSKLMHJKFPVWFUFPVZYRJHIDEVFPJG\\
      ZGKKVJVQVUROTRWIVUJIZOCGZGKKZVZQTDVVRUJHVPRPSLKLFXJZYHEW\\
      YDKWYHGRFUYDMHTUZHUFRHJDIKRWYZVSKDDEZWZREVYRLOUEVPRGVRWV\\
      KHIQVUJWLIWBVWSULWLVJDPVYHNDJDDEZWZRLVRQUEIXKXJLJDEKFQFU\\
      RECHDDEBFXROCGZGJHVWYDKREWYHCXGHIFROZWYUZFVSIHJHEWVGYLDD\\
      BLEJCBTUFZEZYLTKYHULUWYUZFVUVILVVZRVKKZVRPSLKLFQPHKEIXKX\\
      JVRBJKVZRVRPSLKLFXJDEGJXIHYHZVRQYRERIDSOVPRQZVGHRNERKWFG\\
      ZVGUFYVZYDKEIXKXJVGRBHSXKKVUVLRPKRJSVDBZYDKLURBQFZPRLDCO\\
      ULUOFYVKZPFQTHERKZZWYRLWTDLVVZYDKFRXJHNLKKYRCGJBFXKKVQKR\\
      DRLUEIFUYLDRAXUJDHEWKKFXRUKICHUWFEIXKLJKSHRVKVRQUPVQYDMH\\
      CRJWKKVLIUVDJREEVDIZZWYPVPPKVDIWZVZQKKVFFIWLEWYHIHNLKKTD\\
      VVRURQULDXJWGDLVVWZOCLKFFPVERFBWFPV}

 Can you figure out what the two Vigen\`ere keys must have been, and what
 the original cleartext was?
\end{BTtcb}

\vfill
\pagebreak
\section{Preliminary conclusion of preliminaries} 
\label{sec:Pcop}

We have seen that a very old cryptosystem, the Caesar cipher -- which even has
lived into the modern age in the form of ROT13 -- helps illuminate some basic
ideas of the design of cryptosystems and some first steps in attacking them:
basics of cryptography and cryptanalysis.

The attack on the Caesar cipher which we discussed was based on
\textit{frequency analysis}.  There's actually some interesting history here:
As was mentioned above, the Caesar cipher was used by Julius and his nephew
in the first century BCE.  The approach of frequency analysis was first
described nearly a thousand years later, in a book \textit{\ix{Manuscript on Deciphering Cryptographic Messages}} by the Muslim philosopher, mathematician,
physician, and general polymath \ix{Al-Kindi}.  Like the mathematician and
astronomer \ix{Al-Khwarizmi} (whose name came down to modern times in the word
\textit{\ix{algorithm}} and whose book
\textit{\ix{The Compendious Book on Calculation by Completion and Balancing}}
gave us the word \textit{\ix{algebra}}, from it's title in Arabic), Al-Kindi
worked at one of the greatest centers of scholarship in the world in the 8th
century CE, the \ix{House of Wisdom} in Bagdad under the \ix{Abbasid Caliphate}.
Al-Kindi and Al-Khwarizmi seem to have both been involved in bringing an Indian
system for writing numbers using positional notation (so: 101 means one 100
plus no tens plus one 1, whereas the Romans would have written that number CI)
to the Arab world.  This notation later spread to Christian Europe in the early
13${}^{th}$ century through a book called \textit{\ix{Liber Abaci}} (title in
Latin; which would be \textit{\ix{The Book of Calculation}} in English) written
by a man Leonardo of Pisa\index{Leonardo of Pisa (Fibonacci)} ... whom we
know today as \textit{Fibonacci}\index{Fibonacci (Leonardo of Pisa)}.  Some
have claimed that Fibonacci's notation helped bring about the \ix{Renaissance}
in Europe, since without good numerical notation, it would have been very hard
to do double-entry bookkeeping, which was used by great trading houses like the
\ix{Medici}, who then had the funds to support the tremendous flowering of the
arts which was the Renaissance....

The Vigen\`ere cipher\index{Vigenere cryptosystem!history} was invented in the
mid-15${}^{th}$ century (\emph{not} by Vigen\`ere!), used for hundreds of
years by European governments and even by the Confederacy during the American
Civil War, and was described as recently as the early 20${}^{th}$ century as
unbreakable (by none other than
Charles Dodgson\index{Charles Dodgson (Lewis Caroll)}\index{Dodgson, Charles (Lewis Caroll)}, the mathematician known
to us today mostly as Lewis Caroll\index{Lewis Caroll (Charles Dodgson)}\index{Caroll, Lewis (Charles Dodgson)}, the author of
\textit{\ix{Alice in Wonderland}}!).

\vskip2mm
\begin{AZtcb}[label=az:fibonacci]{}{}
  Had you heard of any of this history before?  Did you know of Al-Kwarizmi
  and his connection to the words \textit{algorithm} and \textit{algebra}?
  Had you heard of the House of Wisdom in Bagdad?  Or what about the theory
  that the Renaissance was made possible by the invention of double-entry
  bookkeeping (and therefore, indirectly, by the importation into Christian
  Europe of Hindu-Arabic numbers which made calculations so much easier than
  other systems like the Roman numerals)?
\end{AZtcb}

An enormously important thing we have learned in this chapter, however, is
that:
\begin{quote}
{\bf There is a perfectly secure cryptosystem, the one-time pad.}
\end{quote}
The next time you are watching a movie or TV show which has some line like
``There's no such thing as an unbreakable code,'' you should therefore laugh
derisively.

\vskip2mm
\begin{CTtcb}[label=ct:fullOTP]{}{}
 Before leaving this topic, we should implement a full, one-time pad
 cryptosystem which will work for any kind of data in any language.

 The key to doing this is to think of any data, in any language (or not in a
 language at all), as being simply a string of bits.  Bits, of course, are
 like letters from an alphabet which has only two symbols \textbf{0} and
 \textbf{1}.  We know from \S\ref{ssec:TCcaiv_komm26} that Caesar -- and,
 therefore Vigen\`ere and one-time pads -- only care about keys up to mod of
 the size of the alphabet, which is mod 2 for bits.  So shifting the ``letters''
 \textbf{0} and \textbf{1} by a key of $0$ would do
 $$
 {\mathbf0}\quad {\mathbf1}\overset{{}+0}{\mapsto} {\mathbf0}\quad {\mathbf1}
 $$
 and shifting by a key of $1$ would do
 $$
 {\mathbf0}\quad {\mathbf1}\overset{{}+1}{\mapsto} {\mathbf1}\quad {\mathbf0}
 $$
 Therefore, if the cleartext bit is $a$ and the key bit is $b$, then the
 encrypted bit is $a \wedge b$ (this is the
 ``\ix{exclusive or}'', \ix{XOR}, operation).

 Write a \Python\ function \code{OTP\_gen\_keyfile(f, n)} which takes a
 string  \code{f} and uses it as a filename into which to deposit
 \code{n} random bytes.
 
 Write a \Python\ function \code{OTP\_fileencrypt(f,k)} which a string
 \code{f} and uses it as a name of a file of cleartext data to be
 encrypted. The encryption should use the one-time  pad kept in the file
 with name \code{k} and the output should be put into the file with
 name \code{f+'.enc'}.

 \textit{Some hints:}
 \begin{itemize}
 \item[$\bullet$] You can open a file for reading as bytes with the command
 \code{file\_handle = open(filename,'rb')}.
 \item[$\bullet$] You can get the entire contents of such a file into a byte
 string with the command \code{data=file\_handle.read()}.
 \item[$\bullet$] If \code{a} and \code{b} are \code{int}s,
 then \code{a$\wedge$b} is the bitwise XOR of \code{a} and \code{b}.
 \item[$\bullet$] If \code{bs} is a byte string, then \code{bs[i]},
 (where \code{i} is in \code{range(len(bs))}) is an \code{int}.
 \item[$\bullet$] If you open a file with the flag \code{'wb'}, then
 you can write a byte string \code{bs} to that file with
 \code{file\_handle.write(bs)}.
 \end{itemize}
\end{CTtcb}

\vskip2mm
However, the enormous problem with one-time pads is that:
\begin{quote}
{\bf To remain secure, a one-time pad must have as many key digits as there
are letters in the plaintext to be encrypted, and reuse of pads completely
destroys the security of this cryptosystem.}
\end{quote}
What this means is that the distribution of very large keys is supremely
important in the use of this perfectly secure cryptosystem.

There's a nice story of how important the management of one-time pads can be
from a wonderful book called \textit{\ix{Between Silk and Cyanide: A
Codebreaker's War}} \cite{marks1999between} on cryptology during (part of)
World War II by the author \ix{Leo Marks}.  Marks ran spies into
Nazi-occupied Holland during the war, and when he took over, the spies were
given cyanide pills to take so that they could commit suicide if ever
captured.  That way they would not give away the cryptosystems they used to
radio back to England all the secrets they uncovered.  Instead, under Marks's
direction, they were given large one-time pads, written on sheets of silk
thin enough to be worn underneath their clothes when they were first sent to
Holland.  That way, if captured later, they could tell everything they new
about the codes they used and without having the specific one-time pad used
by other spies or the one they intended to use later, the Nazis could get no
information from intercepted ciphertexts.  Which all meant that captured
spies had no particular reason to commit suicide, and instead could cooperate
and perhaps live out the rest of the war in a POW camp, if captured.

This story of silk undergarments with cryptosystem keys written on them is the
first time we see what will become a recurring theme in this subject:
key distribution\index{key!distribution}, management\index{key!management},
and security can often be the most important practical consideration in
applied cryptography.

\chapter{Block Ciphers}\label{chap:blockciphers}

Most of the encryption today on the Internet is probably done with one of the
cryptosystems called \textit{\ix{block cipher}s}, which do not
provide as perfect cryptographic security as a one-time pad, but which have a
much, much more modest level of difficulty in key management.  Block ciphers
are also very fast and have some nice security features that cryptosystems
structured like the ones we've seen so far do no.

Examples of block ciphers you may have encountered might include:
\begin{itemize}
\item[$\bullet$] \textit{\ix{Advanced Encryption Standard [AES]}}\index{AES (Advanced Encryption Standard)}, authorized by the \ix{National Institute of Standards and Technology [NIST]}\index{NIST: National Institute of Standards and Technology} for use by the US federal government in unclassified
situations;
\item[$\bullet$] the \textit{\ix{Data Encryption Standard [DES]}}\index{DES: Data Encryption Standard}, which was the NIST-authorized block cipher from 1977 to 2001; and
\item[$\bullet$] \textit{3DES}\index{2@3DES, triple DES} or \textit{\ix{triple DES}}, a block cipher pretty much consisting of doing DES three times, which
was used for a while after it was known that DES was nearly broken but before
AES was standardized.
\end{itemize}

In this chapter, we will very briefly touch upon some of the most basic
design principles for \ix{block cipher}s, do a little {\Python}
implementation to explore these principles, and use some code libraries to do
real encryption with state-of-the art block ciphers.

\vfill
\pagebreak
\section{Why encrypt blocks of data: Shannon's confusion and diffusion}
\label{sec:WebodScad}
\index{Shannon, Claude} \index{confusion}\index{diffusion}

Our approach to the cryptanalysis of the Caesar and Vigen\`ere ciphers was based
on the frequencies that individual letters appear in the English language and
also in a ciphertext we are trying to crack.  For some cryptosystems, similar
approaches might be used for longer strings of characters:
\begin{definition}\label{def:monograph}\index{monograph}\label{def:digraph}\index{digraph}\label{def:trigraph}\index{trigraph}
A single letter (from some alphabet) in a piece of text such as a particular
plaintext or ciphertext, or in a large collection of all English texts, is
called a \textbf{monograph}.

Similarly, a pair of adjacent letters in the same kind of text source is
called a \textbf{digraph}, and a sequence of three letters is called a
\textbf{trigraph}.
\end{definition}

So one way to describe our attacks on Caesar and Vigen\`ere is to say that they
compared the statistics of monographs in (various substrings of) a ciphertext
with the same statistics for the English language, which turns out to be a
fairly stable distribution of letter (monograph) frequencies.

Similarly, the frequencies of digraphs in English are fairly stable --
\textit{e.g.,} \textit{th} is quite common, as is \textit{qu}, while both
\textit{tx} and \textit{ql} are very common.  Thus the statistics of
digraphs (and, eventually, trigraphs) can be useful in attacking some
cryptosystems.

\begin{BTtcb}[label=bt:digraph]{}{}
Ignoring non-alphabetic characters and the difference between upper and lower
case, there are $676=26^2$ possible digraphs in English (26 choices for the
first letter of the digraph and 26 choices for the second letter).

Write a \Python\ function \code{digraph\_freq(f, n)} which makes a
relative frequency table of the digraphs from the text in the file with
name \code{f}, printing out the most frequent \code{n} digraphs and
their relative frequencies.  You will want to read in the whole file but, as
we have done before, discard all the non-alphabetic characters and make the
remaining letters all lower case, before counting the digraphs.

Note also that the digraphs can overlap: that is, the string
\begin{center}
\textit{humperdink}
\end{center}
has these digraphs:
\begin{center}
\textit{hu, um, mp, pe, er, rd, di, in,} and \textit{nk}
\end{center}
and not just the non-overlapping ones \textit{hu, mp, er, di}, and \textit{nk}.

Printing out the entire relative frequency table is easier than just the
\code{n} most frequent digraphs.  To do that, you will want to sort the
relative frequency values, and then loop through them in the order of decreasing
frequency.  For each value of a frequency, you will then want to find all
digraphs with that frequency and print it out, increasing a counter as you do.
When the counter gets to \code{n}, you will stop.
\end{BTtcb}

The reason our attack on Caesar using monographs was successful is that Caesar
doesn't hid the statistics of its cleartext letters very well: they're all in
the ciphertext, just shifted over in the alphabet.  In fact, so long as the
way we scramble the letters in a cleartext to get the letters of the
corresponding ciphertext is the same for every letter -- maybe not simply
shifting, like
\begin{tcolorbox}[colback=yellow!5!white,colframe=yellow!75!black]
\hskip-2mm\begin{tikzcd}[column sep=.65cm]
 \mathrm{Plaintext:} & a\ar[dr] & b\ar[dr] & c\ar[dr] & d\ar[dr] & \cdots & \cdots\ar[dr] & y\ar[dr] &
  z\arrow[rounded corners,to head,
          to path={
          -| ([yshift=-2cm,xshift=.5cm]\tikztostart.east)
          -| ([xshift=-.5cm]\tikztotarget.west)\tikztonodes
          -- (\tikztotarget)} ]{dlllllll} \\
  \mathrm{Ciphertext:} & A & B & C & D & \cdots & \cdots & Y & Z
\end{tikzcd}
\end{tcolorbox}
\noindent but even other schemes like
\begin{tcolorbox}[colback=yellow!5!white,colframe=yellow!75!black]
\hskip-2mm\begin{tikzcd}[column sep=.65cm]
 \mathrm{Plaintext:} & a\arrow[dr] & b\ar[dl] & c\ar[dr, crossing over] & d\ar[dl] & \cdots &
 \cdots & y\ar[dr, crossing over] & z\ar[dl]\\
 \mathrm{Ciphertext:} & A & B & C & D & \cdots & \cdots & Y & Z
\end{tikzcd}
\end{tcolorbox}
\noindent which switches the even-numbered letters in the alphabet with the
odd-numbered ones -- the statistics of monographs in our ciphertext will be
the same as in the cleartext, only in some different order.  There's a name
for cryptosystems that do this:
\begin{definition}\label{def:monoalphabeticcryptosystem}\index{monoalphabetic cryptosystem}\label{def:polyalphabeticcryptosystem}\index{polyalphabetic cryptosystem}
A cryptosystem where a single scrambling transformation of letters in the
cleartext to the letters in the ciphertext is called a
\textbf{monoalphabetic cryptosystem}.

A cryptosystem where, instead, the scrambling transformation of letters in the
cleartext to the letters in the ciphertext changes from letter to letter of
the cleartext -- so that, for example, sometimes \textit{a} in the cleartext
is encrypted to \textit{K} in the ciphertext, but other times in the same
cleartext, \textit{a} might be encrypted to \textit{B} or \textit{M} or some
other letter -- depending upon perhaps the other letters in the message or the
location of the cleartext letter in the entire cleartext, is called a
\textbf{polyalphabetic cryptosystem}.
\end{definition}


\vskip2mm
\begin{AZtcb}[label=az:monopolyalphabetic]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting?  Do you feel like you understand which cryptosystems
  are monoalphabetic and which are polyalphabetic -- if so, which of the ones
  we've discussed so far are of which type?
\end{AZtcb}

So (monograph) frequency analysis will make good progress in cryptanalysis
of monoalphabetic cryptosystems, but the relative frequency tables for
ciphertexts from polyalphabetic cryptosystems are smeared out by adding
together lots of differently scrambled versions of the frequency table and so
cryptanalysis this way will be much harder.

In the end, what we are seeing is that when the ciphertexts produced by some
cryptosystem have statistics that somehow reflect the statistics of the
cleartext, then there is a possible avenue of attack.  The best thing, then,
would be if the cleartexts and ciphertexts seemed to be statistically
unrelated to each other

The great mathematician, computer scientist, and cryptologist Claude Shannon\index{Shannon, Claude}\footnote{\tiny Shannon was an enormously influential figure in the history of computer science -- for example, he single-handedly invented the field now known as \textit{Information Theory}\index{information theory}.  He
was also a very colorful character: see \bhref{https://en.wikipedia.org/wiki/Claude_Shannon}{his Wikipedia page}.} in his highly influential (and, initially
classified by the US Government) paper \textit{A Mathematical Theory of Cryptography}\cite{shannon1945mathcrypto}
\begin{definition}\label{def:diffusion}\index{diffusion}
We say that a cryptosystem has the property of \textbf{diffusion} if, for a
fixed choice of key, every time any single bit in a cleartext is flipped,
half of the bits of the ciphertext should change (in general, statistically),
and vice-versa.  (Here, ``statistically'' means that this doesn't have to be
precisely true every time, but when we average over many cleartexts and keys,
on average half of the ciphertext bits will change every time we change any
single cleartext bit.)
\end{definition}

The point of \ix{diffusion} is to minimize the information about the
cleartext which is \textit{leaked}\index{information leakage} by he ciphertext.
The very fact that there is some communication between Alice and Bob is, of
course, leaked.  Looking at the flows of messages between individuals in some
group -- who speaks to whom and when or, in other words, the
\textbf{\ix{metadata}} of the communication -- is called
\textbf{\ix{traffic analysis}} and can be very important. Seeing which
individual is the central point through which all messages flow,
and related issues from traffic analysis, can give information about who is
the leader of the group, \textit{etc..}  As former head of the US National
Security Agency\index{National Security Agency, NSA}\index{NSA, National
Security Agency} General Michael Hayden\index{General Michael
Hayden}\index{Hayden, Michael, General} said\cite{cole2014we}, ``We kill
people based on metadata\index{metadata},''\index{We kill people based on
metadata@``We kill people based on metadata.''}  referring to US drone
strikes\index{drone strikes} on individuals though to be terrorist leaders
based on traffic analysis.

If if we are not trying to understand the organization of some group of
communicating individuals on the basis of their pattern of communications, and
are just looking at Alice and Bob's exchange of encrypted messages, some
things are hard to conceal.  For example, it is nearly impossible to send a
very large piece of information (cleartext) through an encrypted channel
unless the corresponding ciphertext is quite large.

Although, to be fair, the opposite, that a large ciphertext means the
cleartext had a lot of information in it, is not necessarily true.  For
example, Alice could pad a short message with a very large amount of random
extra data and send to Bob the encrypted version of that long cleartext.
That would be a large ciphertext which did not correspond to a large amount of
(useful) information in the cleartext.

\vskip2mm
\begin{AZtcb}[label=az:trafficanalysis]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting?  Do you feel like you understand how an observer could
  use traffic analysis to guess who was the leader of a group of communicating
  individuals?  Can you think of another situations where something like
  traffic analysis comes up in regular life -- maybe when friends or romantic
  partners suddenly are communicating with different people more or less
  frequently...?
\end{AZtcb}

Since it is very hard to prevent the leakage of at least the fact that
communication has occurred, as well as, probably, some idea of how much data
has be transmitted, a good cryptosystem will try to prevent as much other
leakage as possible: Shannon's\index{Shannon, Claude} \ix{diffusion} is one
way to do that.

\vskip2mm
\begin{CTtcb}[label=ct:str_difference_checker]{}{}
 On our way to seeing if the cryptosystems we've met so far have
 \ix{diffusion}:
 
 Write a \Python\ function \code{str\_diff\_display(s,t)} which takes
 two string \code{s} and \code{t} and shows how much they differ.

 Your function should first check if the strings have the same length,
 printing an error and returning 0 if not.

 Next, your function should loop through the strings and print a ``*'' if they
 differ at each location and a ``\_'' if they are the same.  (You might want
 to print these symbols in rows of some determined length, like 30 characters.
 You can do this by printing with commands like \code{print('*',end='')}
 and \code{print('\_',end='')} to stay on the same line, and then using
 \code{print('')} to get to the next line.)

 Your program should then return the number of places where the two strings
 differ (\textit{i.e.}, the number of ``*''s printed).

 For example, running\\
 \code{str\_diff\_display("abc"*30,("abc"*15)+"Abc"+("abc"*13)+"aBc")} should produce the output\\
\hphantom{XXX}\code{\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\vphantom{$X^X$}\hskip1mm}\\[-1.5mm]
\hphantom{XXX}\code{\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_*\_\_\_\_\_\_\_\_\_\_\_\_\_\_\vphantom{$X^X$}}\\[-1.5mm]
\hphantom{XXX}\code{\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_*\_\vphantom{$X^X$}}\\[-1.5mm]
\hphantom{XXX}\code{2\hphantom{\code{\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_,}}}
\end{CTtcb}

\begin{CTtcb}[label=ct:bit_difference_checker]{}{}
 Actually, displaying where two strings have different characters, as
 \code{str\_diff\_display} does, is a pretty crude approximation of showing
 where those strings have different \emph{bits}.  So let's improve the string
 difference display and calculation code to make a bit difference display and
 calculation program.

 In principle, the easiest way to do this is to convert a string of characters
 into a string of characters displaying all of the bits in the first string,
 and then use the \code{str\_diff\_display} you built before.

 To get a character into its binary expression, you can convert it first to
 an \code{int} with \code{ord}, and then convert that \code{int} into a string
 of binary digits with \code{bin}.  The problem with \code{bin} is that it
 always puts a \code{0b} at the front of its binary strings, and it also
 drops off leading 0s.  (That makes sense: when writing the number 17 in base
 10, we don't write it as ``017,'' to indicate there are no 100s, 1 ten, and 7
 ones ... we just write ``17;'' \textit{i.e.,} we drop leading 0s.  The same
 happens in base two.)

 Of course, you can skip the first two characters (like that ``\code{0b}'') of
 a string \code{s} with \code{s[2:]}, and if you have a string \code{b} of 0s
 and 1s that you want to pad on the left with the right number of 0s to make
 it eight symbols long (to show all the bits in that byte), you can
 do \code{('0'*(8-len(b)))+b}.

 Use the above ingredients to make a \Python\ function
 \code{bits\_diff\_display(s,t)} which takes two string \code{s} and \code{t}
 and shows how much their bits differ.  Since there will be eight times as
 may bits to show as there were just for \code{str\_diff\_display(s,t)}, you
 might want to make your lines a bit longer, and maybe show if the bits are
 the same with a ``.'' and if they differ with an ``x.''

 For example, running\\
 \code{bits\_diff\_display("abcdef", "CbcdeF")} should produce the output\\
\hphantom{XXX}\code{..+...+.......................\vphantom{$X^X$}}\\[-1.5mm]
\hphantom{XXX}\code{............+.....\hphantom{+...........}\vphantom{$X^X$}}\\[-1.5mm]
\hphantom{XXX}\code{3\hphantom{\code{++..........................}}}\\
(Even though running\\
\code{str\_diff\_display("abcdef", "CbcdeF")} would produce the output\\
\hphantom{XXX}\code{*\_\_\_\_*\vphantom{$X^X$}}\\[-1.5mm]
\hphantom{XXX}\code{2\hphantom{XXx}\,\,}\\
The difference is because while the strings  \code{"abcdef"} and
\code{"CbcdeF"} differ only in two characters, the first and the last,
the bits for \code{"a"} are \code{01100001} though the bits for \code{"C"}
are \code{01000011} -- so there are \textbf{two} different bits in this
\textbf{one} different character -- and the bits of \code{"f"} are
\code{01100110} though the bits for \code{"F"}
are \code{01000110} -- so there is only one different bit in this one
different character!)
\end{CTtcb}

\vskip2mm
\begin{CTtcb}[label=ct:diffusionCaesarVigenereOTP]{}{}
 Which of the cryptosystems that we have studied so far --
 Caesar\index{Caesar cipher}, Vigen\`ere\index{Vigenere cryptosystem}, and
 \ix{one-time pad}s -- satisfies Shannon's\index{Shannon, Claude} idea of
 \ix{diffusion}?

 Take a fairly long -- maybe 100 characters or so --  cleartext from some
 source, and make two versions of it which differ by only one bit.

 [Note: think a bit about how to make that one-bit change.  Changing one
 letter may not do it!  For example, the letter \textbf{a} is represented
 in Unicode by the number 97, which is has binary expression \textbf{01100001}.
 On the other hand, \textbf{b} in Unicode is 98, which is \textbf{01100010}
 in binary -- so changing \textbf{a} to \textbf{b} changes \textit{two} bits!]

 Once you've got those two strings, make appropriate keys and encrypt both
 strings, then run your \code{bits\_diff\_display} on the encrypted versions
 to see where and how much they differ.  Try this for each of the cryptosystems
 we've done in this class.

 You should now be able to answer the question if those cryptosystems satisfy
 Shannon's\index{Shannon, Claude} diffusion.
\end{CTtcb}

Another thing Shannon\index{Shannon, Claude} worried about was if the
ciphertexts leaked some information about the \textit{key} that was used in
their encryption.  In particular, he made a definition similar to diffusion,
but now looking at keys, as follows:
\begin{definition}\label{def:confusion}\index{confusion}
We say that a cryptosystem has the property of \textbf{confusion} if, working
with a fixed cleartext, every time any single bit in a key is flipped,
half of the bits of the ciphertext should change (in general, statistically),
and vice-versa.  (Here, `statistically'' means that this doesn't have to be
precisely true every time, but when we average over many ciphertexts and keys,
on average half of the ciphertext bits will change every time we change any
single bit of the key.)
\end{definition}

\begin{CTtcb}[label=ct:confusionCaesarVigenereOTP]{}{}
 Which of the cryptosystems that we have studied so far --
 Caesar\index{Caesar cipher}, Vigen\`ere\index{Vigenere cryptosystem}, and
 \ix{one-time pad}s -- satisfies
 Shannon's\index{Shannon, Claude} idea of \ix{confusion}?

 Repeat the previous Code Task \ref{ct:diffusionCaesarVigenereOTP} with now a
 fixed cleartext but trying  encryptions with only one bit changed in the
 key, and see how much of the ciphertext changes.
\end{CTtcb}

The conclusion of this discussion of information leakage is that we should
seek cryptosystems that satisfy confusion and diffusion: they must smoosh up
and mix up the bits of the cleartext and the key, so that, in general,
(nearly) every bit of the ciphertext depends upon (nearly) every bit of both
the cleartext and the key.  This means that we must process the whole
cleartext at once, we cannot handle the bits (characters) of the cleartext
one at a time, as the cryptosystems we've seen so far have done.

This is not easy to do with a fixed cryptographic algorithm for a general
cleartext, so a common approach has been work with chunks of the cleartext
at a time, called blocks, where the blocks all have the same.  At least on
the level of blocks, we can hope that our new cryptographic algorithm will
satisfy confusion and diffusion and therefore reduce information leakage.

This leads us to:
\begin{definition}\label{def:blockcipher}\index{block cipher}\index{block size}
We say that a cryptosystem is a \textbf{block cipher} if it only is defined
when it's input cleartexts and ciphertexts are of some fixed size, called
the \textbf{block size} and if it is deterministic (\textit{i.e.,} it has
not built-in randomness) so it's result depends only upon the input clear-
or ciphertext and the key.
\end{definition}

\vskip2mm
\begin{AZtcb}[label=az:confusiondiffusion]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting? Does it make intuitive sense to you that confusion and
  diffusion would be desirable characteristics for a cryptosystem, and how
  \ix{block cipher}s might relate to that?
\end{AZtcb}

We mentioned at the very beginning of this chapter several well-known
\ix{block cipher}s. Such cryptosystems -- or at
least the ones that have been widely used -- tend to be based on very
primitive but very fast mixing operations on the bits in the messages and the
key.  One particular strategy is to take pieces of the key and do various
operations on it and the message block, to make something called
the \textit{round function}.  Then the full encryption algorithm simply
applies the round function some number of times, each time with a new piece
of key data, again and again to the slowly transforming message block.

\vfill
\pagebreak
\section{Encrypting a block at a time with AES}
\index{block cipher}\index{block size}\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)}
\label{sec:EabaatwAES}

Let's get some practice with using a \ix{block cipher} by looking at the case of
the \textit{Advanced Encryption Standard [AES]}\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)}.  The key for AES must be
of length 16, 24, or 32 bytes [to say it another way: 128, 192, or 256 bits]
while its \ix{block size} is 16 bytes [or 128 bits].

Standard \Python\ distributions should come with the \code{Crypto} package,
which includes \code{AES}\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} among the set of implemented ciphers in
\code{Crypto.Cipher}\index{Crypto [Python module]@\code{Crypto} [Python module]!Crypto.Cipher@\code{Crypto.Cipher}}\index{Python!Crypto.Cipher module@\code{Crypto.Cipher} module}.  Therefore before you can use AES,
you must do\\
\begin{codedisp}
  from Crypto.Cipher import AES
\end{codedisp}

\noindent You can then create an object to work with this cipher by\\
\begin{codedisp}
  cipher=AES.new(key, AES.MODE_ECB)
\end{codedisp}

\noindent The \code{key} must be one of AES's\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} recognized \ix{key} sizes\index{key!size}, or else
this attempted object creation will throw an error (and we'll discuss what
that \code{AES.MODE\_ECB} is doing later...).

An AES object created this way can be used for encryption or decryption (or
both) of a block\index{block size} of 16 bytes of cleartext or ciphertext, always with the key
you used to create the object.  For instance, if your key was
\code{"asdfghijklmnotuv"} then here is an example of encryption\\
\begin{codedisp}
  >>> cipher.encrypt("16 bytes of fun!")
  b'~\x94\xaa\xf6\xc20\x85\xce\x83\x91\xc9\}\xdf\x96\xb8\xcf'
\end{codedisp}

\noindent and here is an example of decryption (assuming the key is still
\code{"asdfghijklmnotuv"})\\
\begin{codedisp}
  >>> cipher.decrypt(
  ... b'~\x94\xaa\xf6\xc20\x85\xce\x83\x91\xc9}\xdf\x96\xb8\xcf')
  b'16 bytes of fun!'
\end{codedisp}

\vskip5mm
\begin{CTtcb}[label=ct:howfastAES]{}{}
 If AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} is going to be a useful standard cipher for wide use on the
 Internet, it should run very fast.  Let's test how fast this by timing how
 long it takes to encrypt one block.  ...Actually, to be safe -- \textit{e.g.,}
 in case some other process takes some time on your computer while you think
 it is only doing an encryption, it is best to do something like 1000
 encryptions, measuring the total time, and then dividing that by 1000.

 A quite direct way to do measure how long something takes is first to run\\
 \hphantom{XXX}\code{import time}\\
 You can then save into a variable the number of seconds since the so-called
 ``Unix Epoch,'' (which was 00:00:00 UTC on 1 January 1970) by\\
 \hphantom{XXX}\code{start\_time=time.time()}\\
 If you then do some processing, you can calculate how long it took with\\
 \hphantom{XXX}\code{elapsed\_time=time.time()-start\_time}.

 When using this approach to measuring computational speed, you should
 be careful only to do the repeated runs of the commands you want to time
 between the two invocations of \code{time.time()} -- run nothing superfluous!
 For example, make one AES cipher object before you start the timing, so that
 the computational cost of building that object doesn't get counted when you
 are trying to figure out the cost of encryption (or decryption).

 With all that in mind, make some 16 byte AES key and 16 byte cleartext, time
 how long it takes to do 1000 encryptions and 1000 decryptions, and report on
 how long it takes, on average, for each encryption or decryption.  It would
 be nice to change the message and/or the key each of the 1000 times -- but
 call some random number generator in the loop, then you'll be timing
 \textit{that} as much as encryption/decryption!
\end{CTtcb}

\begin{CTtcb}[label=ct:diffusionAES]{}{}
 Does AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} satisfy Shannon's\index{Shannon, Claude} idea of
 \ix{diffusion}?

 To see, take some cleartext of length 16 bytes and make two versions of it
 which differ by only one bit.

 Then make a 16 byte key, create an instance of AES, and make ciphertexts for
 the two different cleartexts (but the same key). Use your program
 \code{bits\_diff\_display} to see where and how much the two ciphertexts
 differ.

 You might also try the above for several different keys, just to make sure that
 it's not a fluke which is special for the choice of key you happened to make.
\end{CTtcb}

\begin{CTtcb}[label=ct:confusionAES]{}{}
 Does AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} satisfy Shannon's\index{Shannon, Claude} idea of
 \ix{confusion}?

 To see, take some cleartext of length 16 bytes.  Make two different keys of
 length 16 bytes which differ by only one bit.  First with one key, make an AES
 cipher object and encrypt the fixed cleartext, then do the same using the other
 key.  Use your program
 \code{bits\_diff\_display} to see where and how much the two resulting
 ciphertexts differ.

 You might also try the above for several different ciphertexts, just to make
 sure that it's not a fluke which is special for the choice of key you
 happened to make.
\end{CTtcb}

\vskip2mm
\begin{AZtcb}[label=az:AES]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting? Was it easy or hard to use \Python's AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)}?  What do you
  find most annoying and/or convenient about this implementation of AES?
\end{AZtcb}

\vfill
\pagebreak
\section{Encrypting more or less than a block with a block cipher}
\label{sec:Emoltabwabc}
\index{block cipher}

If Alice and Bob know they will always be exchanging messages which are exactly
the number of bytes in the \ix{block size} of the \ix{block cipher} they are
using, they're in very good shape.  What is much more likely, though, is that
they will send smaller or (much) larger messages, and we ought to help them do
that securely.

\vskip1cm
\subsection{Very small messages need some \textit{padding}}
\label{ssec:Emoltabwabc_vsmnsp}
When a message is smaller than the \ix{block size}, it seems pretty easy
simply to add some extra stuff to fill up an entire block: this extra data is
called \textbf{\ix{padding}}.  The problem is, if the message can could be
arbitrary data, then how do we tell what is message and what is padding?

A common way to do this, when we know that there will have to be some padding
(maybe metadata that goes along with the message, like in the subject line of
an email or in the packet metadata for an encrypted packet sent on a
packet-switched network), is to assume that there is always at least one byte
of padding: the last one.  That byte can carry information, though, so it can
simply tell the number of bytes of padding or, conversely, the number of actual
non-padding bytes in the block.

\vskip2mm
\begin{CTtcb}[label=ct:padding_scheme]{}{}
 Write a \Python\ function \code{pad\_string(s, n)} which takes as input a
 string \code{s} and \ix{block size} \code{n} and returns a string of length
 \code{n}, using \ix{padding} as described above.

 If \code{len(s)>n-1}, you should print an error and return the empty string,
 since there will be no room for padding.  Otherwise, return a string whose
 first characters are just a copy of \code{s} and whose remaining bytes are
 just some copies of the number \code{len(s)}.

 Also write a function \code{unpad\_string(s)} which takes as input a
 string \code{s}, assumed to come from the \code{pad\_string()} function, and 
 returns the original string without padding.

 For \code{unpad\_string}, you can assume the \ix{block size} used in the
 \code{pad\_string} was simply \code{len(s)} and the last byte of \code{s} is a
 number telling how much of \code{s} is the original string.  Therefore, if
 \code{ord(s[-1])>len(s)-1} then there's some sort of problem and you should
 print out an error message and return the null string.  Otherwise, return
 the first \code{ord(s[-1])} character substring of \code{s}.

 \textit{E.g.,} \code{pad\_string('test',16)} should return\\
 \hphantom{XXX}\code{'test{\textbackslash}x04{\textbackslash}x04{\textbackslash}x04{\textbackslash}x04{\textbackslash}x04{\textbackslash}x04{\textbackslash}x04{\textbackslash}x04{\textbackslash}x04{\textbackslash}x04{\textbackslash}x04{\textbackslash}x04'}\\
 and \code{unpad\_string('fishhead{\textbackslash}x08{\textbackslash}x08{\textbackslash}x08{\textbackslash}x08{\textbackslash}x08{\textbackslash}x08{\textbackslash}x08{\textbackslash}x08')}
 should return\\
 \hphantom{XXX}\code{'fishhead'}.
\end{CTtcb}

\vskip2mm
\begin{CTtcb}[label=ct:AES_for_short_messages]{}{}
 Write a \Python\ function \code{smallAESencrypt(k, s)} which takes as input an
 AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} key \code{k} and cleartext string \code{s}, where \code{len(s) &lt; 16} and
 returns the AES encryption of the padded\index{padding} version of \code{s}.

 If \code{len(s)>15} or if \code{k} is not a valid AES key, you should print
 an error and return the empty string.

 Also write a function \code{smallAESdecrypt(k, t)} which takes as input an
 AES key \code{k} and AES ciphertext \code{t}, assumed to come from
 \code{smallAESencrypt(k, s)} function, and returns the original cleartext
 string \code{s} (without padding).
\end{CTtcb}

\vskip2mm
\begin{AZtcb}[label=az:padding]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting? Can you think of a different (or better) \ix{padding}
  scheme?
\end{AZtcb}

\vskip1cm
\subsection{Larger messages require \textit{\it{block chaining}}}
\label{ssec:Emoltabwabc_lmrbc}

What if a cleartext is longer than the \ix{block size} of the \ix{block cipher}
we are using?  The obvious thing would be simply to break the cleartext into
some number of full blocks and then one last block which is smaller, and to use
regular block encryption on the full blocks and
padding-plus-encryption\index{padding} on the last, smaller block.

\vskip2mm
\begin{CTtcb}[label=ct:naivelargeblockmsgenc]{}{}
Implement that scheme for the AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} block cipher\index{block cipher}.  That is:

Write a \Python\ function \code{naiveAESencrypt(k, s)} which takes as
input an AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} key \code{k} and cleartext string \code{s}.  It should then
build up a return value as follows:
\begin{enumerate}
\item for each full block of cleartext (there may be none such, if the
\code{len(s) &lt; 16}), append to the return value the regular AES encryption of that
block with key \code{k}
\item append to the return value the output of \code{smallAESencrypt(k, small)},
where \code{small} is the last piece of the cleartext, whose length is less
than 16 bytes.
\end{enumerate}

Also write a \Python\ function \code{naiveAESdecrypt(k, t)} which takes as
input an AES key \code{k} and ciphertext string \code{t}.  It should then
build up a return value as follows:
\begin{enumerate}
\item if \code{t} has more than 16 bytes, for each block of 16 bytes in \code{t}
except the last, append the plain AES decryption of that block with key
\code{k} to the return value
\item when done with that, append \code{smallAESdecrypt(k, last)} to the return
value, where the variable \code{last} contains the last 16 bytes of \code{t}
\end{enumerate}
\end{CTtcb}

But now we've got to wonder if this naive approach to AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} on large messages
still satisfies Shannon's \ix{diffusion} condition.
\begin{CTtcb}[label=ct:naivelargeAESdiffusion]{}{}
Re-do Code Task \ref{ct:diffusionAES} but now using two cleartexts of length
80 bytes which differ by one bit near the middle, and using the
\code{naiveAESencrypt} function.
\end{CTtcb}

How are we going to get a \ix{block cipher} that satisfies
Shannon's\index{Shannon, Claude} \ix{diffusion} condition?  A good block cipher
will diffuse nicely ... within a block.  But the \ix{block size} is
fixed, and we have to somehow spread the diffusion -- which, remember,
basically means that changing on bit in the cleartext changes around half of
the bits of the ciphertext -- around in each block.  One way might be just to
design a new block cipher for each new cleartext whose block size is larger
than the size of the cleartext and which does nice diffusion across that
block.  But it's so hard to verify that ciphers are really secure, this is
completely impractical.

Instead, the most common approach is to use a block cipher of some fixed size
(like AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)}) and to make the encryption of each block depend also on what
happened with previous blocks: this is called \textbf{\ix{block chaining}}.

There are two things we need to think about for block chaining.
\begin{enumerate}
\item \textbf{How exactly to chain the blocks:} There are various ways to chain
the encryption of blocks and achieve \ix{diffusion}.  Here's one:
Suppose we change one bit in a block of cleartext.  If we're using a
well-designed \ix{block cipher}, about half of the bits of the
ciphertext will change as well.  We can use these different bits to change the
bits of the next block of plaintext, by bitwise
\ix{XOR}ing\index{exclusive or} (\textit{i.e.}, bitwise addition mod 2)
the ciphertext block with that next block of cleartext.  That will propagate
the change to half of the bits of the corresponding ciphertext, and repeating
for each successive block, we will have spread the changed bits all down the
sequences of blocks of the ciphertext coming from the long cleartext.

\item \textbf{How to start the chaining:} The very first block will not have a
predecessor block off of which to chain.  It turns out that this can cause
security issues, so the way to handle this is to make a block's worth of
random data, called the
\textbf{\ix{initialization vector (IV)}}\index{IV, initialization vector},
and to start chaining as if that IV were the ciphertext from the previous
block.  Alice should then send the random IV that she chose along with the
ciphertext so that Bob can decrypt the long message.
\end{enumerate}

\begin{definition}\label{def:CBCmode}\index{Cipher Block Chaining (CBC) mode block chaining}\index{CBC mode block chaining}\index{block chaining!Cipher Block Chaining (CBC) mode} The block chaining approach
just described is called \textbf{Cipher Block Chaining} or \textbf{CBC mode}
block chaining. Symbolically, it works like this:
\begin{figure}[H]
 \centering
 \includegraphics[height=6cm]{CBC_encryption.eps}
 \label{fig:CBC_encryption}
\end{figure}
\noindent for encryption and like this:
\begin{figure}[H]
 \centering
 \includegraphics[height=6cm]{CBC_decryption.eps}
 \label{fig:CBC_decryption}
\end{figure}
\noindent for decryption.  (In diagrams like this, the symbol
``${}\oplus{}$''\index{1@${}\oplus{}$, bitwise XOR} stands for bitwise
XOR\index{exclusive or}\index{XOR} (\textit{i.e.}.)
\end{definition}

Note that the way we discussed before of doing encryption of long messages
with a block cipher, which simply treated each block entirely separately and
failed Shannon's\index{Shannon, Claude} \ix{diffusion} condition
is, in the context of block chaining schemes, called
\textbf{Electronic Codebook mode}\index{Electronic Codebook (ECB) mode block chaining}\index{block chaining!Electronic Code Book (ECB) mode} or
\textbf{ECB mode}\index{ECB mode block chaining} chaining and has the simple diagram:
\begin{figure}[H]
 \centering
 \includegraphics[height=6cm]{ECB_encryption.eps}
 \label{fig:EBC_encryption}
\end{figure}
\noindent for encryption and
\begin{figure}[H]
 \centering
 \includegraphics[height=6cm]{ECB_decryption.eps}
 \label{fig:ECB_decryption}
\end{figure}
\noindent for decryption.

The way a \ix{block chaining} mode is chosen in \Python\ is in the creation of
a \code{Crypto.Cipher}\index{Crypto [Python module]@\code{Crypto} [Python module]!Crypto.Cipher@\code{Crypto.Cipher}}\index{Python!Crypto.Cipher module@\code{Crypto.Cipher} module} object.  Where, in the past, we
have used \code{AES.MODE\_ECB} for Electronic Code
Book\index{Electronic Codebook (ECB) mode block chaining}\index{block chaining!Electronic Code Book (ECB) mode}\index{ECB mode block chaining} chaining, we
can use instead \code{AES.MODE\_CBC} for cipher block
chaining\index{Cipher Block Chaining (CBC) mode block chaining}\index{CBC mode block chaining}\index{block chaining!Cipher Block Chaining (CBC) mode} as
described above.  Since that mode requires an initialization vector\index{initialization vector (IV)}\index{IV, initialization vector}, Alice must specify the
16-byte IV they want to use, as follows:\index{Crypto [Python module]@\code{Crypto} [Python module]!Crypto.Cipher@\code{Crypto.Cipher}}\index{Python!Crypto.Cipher module@\code{Crypto.Cipher} module}\\
\begin{codedisp}
  from Crypto.Cipher import AES
  key=b'randobytes 4 key'  # not a good choice of key
  iv=b'IV of randobytes'   # terrible choice of IV
  cipher=AES.new(key,AES.MODE_CBC,iv)
  ciphertext=cipher.encrypt(b'some cleartext w/ len two blocks')
  message=iv+ciphertext    # put together IV and ciphertext
                           # to be transmitted to Bob
\end{codedisp}

\noindent The original message can then be recovered with\index{Crypto [Python module]@\code{Crypto} [Python module]!Crypto.Cipher@\code{Crypto.Cipher}}\index{Python!Crypto.Cipher module@\code{Crypto.Cipher} module}\\
\begin{codedisp}
  from Crypto.Cipher import AES
  key=b'randobytes 4 key' # Bob must know the same key
  iv=message[:16]         # Bob grabs the IV out of the message
  ciphertext=message[16:] # the rest of the message is ciphertext
  cipher=AES.new(key,AES.MODE_CBC,iv)
  cleartext=cipher.decrypt(ciphertext)
\end{codedisp}

Note that the \code{Crypto.Cipher}\index{Crypto [Python module]@\code{Crypto} [Python module]!Crypto.Cipher@\code{Crypto.Cipher}}\index{Python!Crypto.Cipher module@\code{Crypto.Cipher} module} object is
\textbf{\ix{stateful}} in CBC\index{Cipher Block Chaining (CBC) mode block chaining}\index{CBC mode block chaining}\index{block chaining!Cipher Block Chaining (CBC) mode} mode -- meaning that it remembers what it has seen before.  When it
is created, it uses the given IV to start the chaining, but thereafter, every
call to \code{encrypt} chains off of the previous block.  That is, the way of
encrypting the two-block cleartext\ \code{b'some cleartext w/ len two blocks'}
described above yields exactly the same result as doing
instead\index{Crypto [Python module]@\code{Crypto} [Python module]!Crypto.Cipher@\code{Crypto.Cipher}}\index{Python!Crypto.Cipher module@\code{Crypto.Cipher} module}\\
\begin{codedisp}
  from Crypto.Cipher import AES
  key=b'randobytes 4 key'  # not a good choice of key
  iv=b'IV of randobytes'   # terrible choice of IV
  cipher=AES.new(key,AES.MODE_CBC,iv)
  ciphertext_part1=cipher.encrypt(b'some cleartext w')
  ciphertext_part2=cipher.encrypt(b'/ len two blocks')
  ciphertext_full=ciphertext1+ciphertext2
  message=iv+ciphertext    # put together IV and ciphertext
                           # to be transmitted to Bob
\end{codedisp}

\vskip2mm
\begin{AZtcb}[label=az:chaining]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting? Can you think of a different (or better) approach to
  \ix{block chaining}? Do you see why chaining is good, and why an
  initialization vector\index{initialization vector (IV)}\index{IV, initialization vector} is a good idea?
\end{AZtcb}

\vskip4mm
Finally, we can see to what extent block chaining makes a version of
AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} which satisfies Shannon's\index{Shannon, Claude} \ix{diffusion}
condition ... to some extent.

\vskip2mm
\begin{CTtcb}[label=ct:sophisticatedlargeAESdiffusion]{}{}
Re-do Code Task \ref{ct:naivelargeAESdiffusion} but now using AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} in
CBC\index{Cipher Block Chaining (CBC) mode block chaining}\index{CBC mode block chaining}\index{block chaining!Cipher Block Chaining (CBC) mode} mode.
\end{CTtcb}

\vfill
\pagebreak
\section{Some concluding observations for block ciphers}
\label{sec:Sco4bc}

Modern block ciphers like AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} can run quite fast (that should have been
the conclusion of Coding Task \ref{ct:howfastAES}).  Using some, but not all,
\ix{block chaining} modes, they can satisfy Shannon's\index{Shannon, Claude}
\ix{diffusion} condition, at least a sort of
\textit{\ix{forward diffusion}\index{diffusion, forward}} in that when two
messages differ by one bit, then about half the bits in the corresponding
blocks in the two ciphertexts are different, and also for all blocks
after (but not before!) that one.

This makes block ciphers quite good to use in practice... assuming they're
secure.  Fortunately, at the moment, there is no known, general-purpose attack
against the AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} cryptosystem better than brute force\index{brute-force attack}.

Let's think through some issues around a \ix{brute-force attack} on AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)}.  The
\ix{key} size\index{key!size} we've been using is 16 bytes, or 128 bits.  If a random key is chosen,
then $2^{127}$ keys will have to be tried, on average, in a \ix{brute-force attack}
before the correct one is guessed.  $2^127$ is about $1.7\times10^{38}$, which
means that if you could check a billion possible keys a second, then it would
take roughly 100 billion times the life of universe (which is around
$4.3\times10^{17}$ seconds) to do one \ix{brute-force attack} on AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)}.

\vskip2mm
\begin{CTtcb}[label=ct:bruteforceAESattack]{}{}
We should at least try a \ix{brute-force attack} against
AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} ... at least in a very special case (we don't want to wait billions of times
the life of the universe!).

Suppose Eve thinks Alice has sent her password to Bob in a message which was
encrypted with the AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} cipher using Electronic Code
Book\index{Electronic Codebook (ECB) mode block chaining}\index{block chaining!Electronic Code Book (ECB) mode}\index{ECB mode block chaining} mode chaining.  Eve
also knows that Alice and Bob's favorite number is 17, so she thinks that they
will probably use a key which is mostly 17s.  In fact, Eve guesses that the key
will be 15 bytes all with the value 17 followed by one new, random byte.

Eve can try all possible keys of this form with code like this:\\
\begin{codedisp}
  key_ints=[17]*16  # last 17 is probably not right,
                    # it's just here to make a list of
                    # the correct length
  for i in range(256):
    key_ints[15]=i
    possible_key=bytes(key_ints)
    # make an AES object with that possible_key
    # and use it to try decrypting the ciphertext
\end{codedisp}

Eve also guesses that the word ``password'' will appear in the cleartext.
{\Python} has a nice command to check if a substring is present in a string,
the command \code{in}, which works both with normal strings and substrings and
also byte strings and potential byte substrings.  Eve can use this as follows:\\
\begin{codedisp}
  # inside a loop making attempted decryptions which
  # are in a variable possible_cleartext
  if b'password' in possible_cleartext:
    print('Found the cleartext!  It should be: ',end='')
    print(possible_cleartext)
\end{codedisp}

\vskip3mm
If Eve were to try the above approach to decrypt the stolen ciphertext\\
\begin{codedisp}
b"h9\xf2\x12,\x5e.\xab\xf4M\x1e\xf5\xc9\xcea\r"
\end{codedisp}

what password
would she find, and what would be the key that unlocked it?  [Show all of
Eve's code as well as answering those questions!]
\end{CTtcb}

\vskip2mm
\begin{CTtcb}[label=ct:harderbruteforceAESattack]{}{}
Repeat the previous Code Task \ref{ct:bruteforceAESattack}, but suppose now
that Eve thinks that only the first 14 bytes of the key are 17s, the last two
might be anything.

In this situation, try to use the same general approach (but probably with two
nested loops, to try all 256 possible bytes in both of the last two bytes of
the key) to decrypt the stolen ciphertext\\
\begin{codedisp}
b"\xe0\xb3W\x94/X\xe7.\x93\xda\xe9\xed\xde\xedT\xfe"
\end{codedisp}
\end{CTtcb}

\begin{BTtcb}[label=bt:hardestbruteforceAESattack]{}{}
Repeat the prior Code Task \ref{ct:bruteforceAESattack} one more time, but
suppose now that Eve thinks that 15 of the bytes of the key are 17s, while the
last byte -- call it the ``wildcard key byte'' -- might be anything ... and that
wildcard byte might be at any location of the key.

In this situation, try to use the same general approach (but probably with two
nested loops, one to loop through the 16 possible locations for the wildcard key
byte, the other then to try all 256 possible values for the wildcard byte) to
decrypt the stolen ciphertext\\
\begin{codedisp}
b"0\xbd\x9e*\x9b\xd4\x03\xa58&lt;\xfa\x0e\x86J\xfd@"
\end{codedisp}
\end{BTtcb}

In the Code Tasks \ref{ct:bruteforceAESattack} and \ref{ct:harderbruteforceAESattack} and the Bonus Task \ref{bt:hardestbruteforceAESattack} above, we imagined
that Eve would somehow know that the cleartext behind the ciphertext she had
stolen contained the substring \code{b'password'}.  This kind of thing has a name:
\begin{definition}\label{def:crib}
If a cryptanalyst is trying to discover the cleartext which generated a particular
ciphertext and knows (or at least hopes) some substring of the unknown full
cleartext, then that substring is called a \textbf{\ix{crib}}.
\end{definition}
Cribs are actually not all that uncommon.  Cleartexts often have a standard
header which includes the date and time, which the cryptanalyst might know
for other reasons, so the correctly formatted time-and-date string can be used
as a crib.  Famously, the Nazi military communications during WWII always
included a well-known phrase signaling fealty to the leader of the Third
Reich\footnote{Which we will not quote exactly here, because it would be
unpleasant to have that odious phrase be a substring of this book!}, which
could be used as a crib.

\vskip2mm
\begin{AZtcb}[label=az:cribs]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting? Can you think of a ``crib'' in messages you often send
  or receive, maybe to or from a family member, or someone (or some
  organization) with which you regularly communicate on the 'net for work,
  school, or entertainment?
\end{AZtcb}

\begin{BTtcb}[label=bt:enigma]{}{}
Here's an entirely non-coding Bonus Task:

Cribs were very important in cracking the Enigma cryptosystem which was used
by the Nazis during WWII -- which shortened the war by years, it has been
estimated (see ``\bhref{https://www.bbc.com/news/technology-18419691}{Alan Turing: The codebreaker who saved 'millions of lives'}'' from \bhref{https://www.bbc.com/}{The BBC}).

Write a one-page (or so) ``mini-paper'' on the Enigma, as a cryptosystem, its
role in history, and something about how it was cracked.  This should include
\begin{itemize}
\item[$\bullet$] A short description of how the Enigma cryptosystem worked --
use as many of the technical terms from this course that you can (\textit{e.g,},
what was the \textit{\ix{keyspace}}, was it a \textit{mono-}\index{monoalphabetic cryptosystem} or \textit{\ix{polyalphabetic cryptosystem}} or neither,
\textit{etc.}); this should be about half of your ``mini-paper.''
\item[$\bullet$] A very short description of the Enigma's historical role in
the war; about one sixth of your ``mini-paper.''
\item[$\bullet$] A short, very high-level description of the effort made by the
Allies to crack the Enigma cryptosystem -- mention \textit{\ix{cribs}}; about
one third of your  ``mini-paper.''
\end{itemize}

Sources you might use are:
\begin{itemize}
\item[$\bullet$] The BBC story mentioned above.
\item[$\bullet$] \bhref{https://en.wikipedia.org/wiki/Enigma\_machine}{The Wikipedia page ``Enigma machine''}
\item[$\bullet$] \bhref{https://en.wikipedia.org/wiki/Cryptanalysis\_of\_the\_Enigma}{The Wikipedia page ``Cryptanalysis of the Enigma''}
\item[$\bullet$] \bhref{https://cryptomuseum.com/index.htm}{The Crypto Museum}'s\ page\ ``\bhref{https://cryptomuseum.com/crypto/enigma/hist.htm}{History of the Enigma}''
\end{itemize}
\end{BTtcb}

\vskip3mm
We have seen that block ciphers can be fast, easy to use, and highly secure.

But we did see that the security is based in part on the size\index{key!size} of, and lack of
structure in, the \ix{key}s: it was that \ix{keyspace} of size $2^128$, along
with a lack of some foolish structure like ``15 of the 16 bytes are just
representations of the number 17,'' which made AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} so secure.

Which means that it is really important for Alice and Bob to be able to share
-- very accurately, since even a single incorrect bit with scramble their
messages catastrophically! -- a large, random-seeming \ix{key}.  In the modern,
networked,  world, where we often want to share valuable information very
securely with people whom we may have never met in person, this is a serious
defect.  You may want to get your credit card number to an online store from
your laptop, first through the open WiFi at a coffee shop, then across the
(insecure by design) Internet!  Cryptography is clearly a vital tool to do a
thing like that, but the cryptosystems we have seen so far all require a
shared secret, the \ix{key}, which is hard to achieve in common modern
situations like this.

In the next chapter we start to talk a solution to this problem of \ix{key}
sharing: cryptosystems where [part of] the \ix{key}s can be public,

\chapter{Asymmetric [Public-Key] Cryptosystems}\label{chap:asymmetricCSs}

We have seen that there are secure, fast, (relatively) easy-to-use
cryptosystems, but which do require a special activity before the regular
communication can start: secure, secret key sharing.  There are various
approaches to getting around the practical difficulty this may present in the
real world (such as, noted above, getting your credit card number securely to
an online vendor with whom you have not had the opportunity to perform the
secret key-sharing ritual), including:
\begin{itemize}
\item[$\bullet$] There are protocols which allow two parties to create a shared
secret by exchanging messages on a public network: Alice and Bob must merely
exchange two messages and they will end up with a common secret value that
Eve, even if she saw both of the messages, will not be able to compute.
That shared value can then be used, directly or after further processing, as
the key for a block cipher for more secure communication.  The most famous of
these protocols is \ix{Diffie-Hellman key exchange}, about which more
information can be found, \textit{e.g.}, here:
\begin{itemize}
\item[$\circ$] \bhref{https://en.wikipedia.org/wiki/Diffie-Hellman\_key\_exchange}{The Wikipedia page ``Diffie-Hellman key exchange''}
\item[$\circ$] \bhref{https://ieeexplore.ieee.org/document/1006971}{a nice survey article} \cite{hellman2002}
\item[$\circ$] \bhref{https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.9720}{the original paper about their discovery by Diffie and Hellman} \cite{diffie1976new}
\end{itemize}
The details of Diffie-Hellman are based on some modest mathematics: it is quite
accessible to an advanced undergraduate mathematics major.  It's security rests
on a hypothesis which is widely believed -- but not proven! -- by many
mathematicians and computer scientists.
\item[$\bullet$] Instead of basing a secure way for parties to build a
shared secret by communications over a public channel on theoretical
hypotheses, there is way to do the same thing using some specialized hardware
and a deep understanding of \ix{quantum mechanics}.  Called
\textbf{\ix{quantum key distribution, [QKD]}}\index{QKD, quantum key distribution}\index{key!distribution!quantum} and invented in the 1980s, this approach has been demonstrated first in
the laboratory over ever longer distances since then, but is not yet in
wide use in practice.  For more information:
\begin{itemize}
\item[$\circ$] \bhref{https://en.wikipedia.org/wiki/Quantum\_key\_distribution}{The Wikipedia page ``Quantum key distribution''}
\item[$\circ$] a general introductory site: \bhref{https://web.archive.org/web/20131225083723/https://uwaterloo.ca/institute-for-quantum-computing/quantum-computing-101}{Quantum computing 101}
\item[$\circ$] \bhref{https://arxiv.org/pdf/2003.06557.pdf}{the original 1984 research paper on this subject, by Bennett and Brassard} \cite{bennett2020quantum}
\end{itemize}
\item[$\bullet$] Another approach, with wide and interesting application is the
subject of most of this chapter:
\ix{asymmetric cryptosystem}s\index{cryptosystem!asymmetric}.
\end{itemize}

\vfill
\pagebreak
\section{Symmetric, asymmetric, and salty cryptosystems: basics}
\index{symmetric cryptosystem}\index{cryptosystem!symmetric}\index{asymmetric cryptosystem}\index{cryptosystem!asymmetric}\index{cryptographic salt}\index{salt!cryptographic}\label{sec:SAaSCB}

Looking more closely, the problem we noticed at the end of the last chapter
stems from the fact that Alice and Bob both have to have the same \ix{key} to
encrypt and decrypt, which they must therefore keep away from Eve.  After
all, if Eve had the key, she could encrypt and send messages to Bob
pretending that they came from Alice, and Eve could also intercept and
decrypt the real messages that Alice was sending to Bob.  That's the problem
with using the same key.  Cryptosystems that do this have a name:

\begin{definition}\label{def:symmetricCS}
A \textbf{\ix{symmetric cryptosystem}}\index{cryptosystem!symmetric} is one
in which the same key is used both to encrypt cleartexts to ciphertexts and
also to decrypt ciphertexts to cleartexts.

Sometimes \ix{symmetric cryptosystem}s are also called
\textbf{\ix{private-key cryptosystem}s}\index{cryptosystem!private key}.
\end{definition}

Graphically, symmetric cryptosystems work like this:

\vskip2mm
\centerline{\ \ \ \ \large\textbf{Symmetric [private-key] cryptosystem, graphically:}}
\vskip2mm
\begin{adjustbox}{center}
  \begin{tabular}{|c|c|c|}
    \hline
    \multicolumn{3}{|c|}{private agreement}\\
    \multicolumn{3}{|c|}{Alice\ \ \qquad\qquad$\longleftrightarrow$\quad of shared key $k$\qquad$\longleftrightarrow$\qquad\qquad\quad Bob}\\
    \hline
    \hline
    & on public network & \\
    & (where Eve is watching) & \\
    \hline
    creates cleartext message $m_A$; & & \\
    using $k$, encrypts $m_A$ to $c_A$ & &\\
    and transmits $c_A$ & \ \quad$\rightarrowtail\ \ \ $ ciphertext $c_A\ \ \ \rightarrowtail$\quad\  & receives $c_A$;\\
    & & using $k$, decrypts $c_A$\\
    & &\ \ and recovers cleartext $m_A$\ \ \ \\
    \hline
    & & creates cleartext message $m_B$;\\
    & & using $k$, encrypts $m_B$ to $c_B$\\
    receives $c_B$; & \ \quad$\leftarrowtail\ \ \ $ ciphertext $c_B\ \ \ \leftarrowtail$\quad\  & and transmits $c_B$\\
    using $k$, decrypts $c_B$& &\\
    and recovers cleartext $m_B$ & &\\
    \hline
    \multicolumn{3}{|l|}{\quad\qquad\qquad\qquad\qquad$\vphantom{\begin{matrix}1\\1\end{matrix}}${\it etc....}} \\
    \hline
  \end{tabular}\\
  \ \\
\end{adjustbox}

\vskip2mm
The problem we're dealing with now is the initial private agreement of
the secret \ix{key} $k$.

A way to get around this problem would be if Alice and Bob used different
keys for encryption and decryption.  There's a name for this type of
cryptosystem:

\begin{definition}\label{def:asymmetricCS}
An \textbf{\ix{asymmetric cryptosystem}}\index{cryptosystem!asymmetric} is one
in which one key $k_e$ -- called the \textbf{encryption} or
\textbf{\ix{public key}}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]}
-- is used to encrypt cleartexts to ciphertexts, while a different key $k_d$ --
called the \textbf{decryption} or
\textbf{\ix{private key}}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]}
-- is needed to decrypt ciphertexts to cleartexts.

Sometimes \ix{asymmetric cryptosystem}s are also called
\textbf{\ix{public-key cryptosystem}s}\index{cryptosystem!public key}, because
usually when one is using them, one posts one's encryption key\index{encryption key [for an asymmetric cryptosystem]}\index{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]} $k_e$ in a public place
to everyone to see and use.
\end{definition}

Graphically, asymmetric cryptosystems work like this:

\vskip2mm
\centerline{\large\textbf{Asymmetric [public-key] cryptosystem, graphically:}}
\vskip2mm
\begin{adjustbox}{center}
  \begin{tabular}{|c|c|c|}
    \hline
    Alice & on public network & Bob\\
    & (where Eve is watching) & \\
    \hline
    generate key pair $(k^A_e,k^A_d)$ & & generate key pair $(k^B_e,k^B_d)$\\
    download $k^B_e$ & $\leftarrowtail\ \ \ $ public encryption key\index{encryption key [for an asymmetric cryptosystem]}\index{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\ $k^B_e\ \ \ \leftarrowtail$ & publish $k^B_e$\\
    publish $k^A_e$ & $\rightarrowtail\ \ \ $ public encryption key\index{encryption key [for an asymmetric cryptosystem]}\index{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\ $k^A_e\ \ \ \rightarrowtail$ & download $k^A_e$\\
    \hline
    create cleartext message $m_A$; & & \\
    using $k^B_e$, encrypt $m_A$ to $c_A$ & &\\
    and transmit $c_A$ & \ \quad$\rightarrowtail\ \ \ $ ciphertext $c_A\ \ \ \rightarrowtail$\quad\  & receive $c_A$;\\
    & & using $k^B_d$, decrypt $c_A$\\
    & &\ \ and recover cleartext $m_A$\ \ \ \\
    \hline
    & & create cleartext message $m_B$;\\
    & & using $k^A_e$, encrypt $m_B$ to $c_B$\\
    receive $c_B$; & \ \quad$\leftarrowtail\ \ \ $ ciphertext $c_B\ \ \ \leftarrowtail$\quad\  & and transmit $c_B$\\
    using $k^A_d$, decrypt $c_B$& &\\
    and recover cleartext $m_B$ & &\\
    \hline
    \multicolumn{3}{|l|}{\quad\qquad\qquad\qquad\qquad$\vphantom{\begin{matrix}1\\1\end{matrix}}${\it etc....}} \\
    \hline
  \end{tabular}\\
  \ \\
\end{adjustbox}

\vskip2mm
\begin{AZtcb}[label=az:asymmetricCS]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting?  Do you understand how Alice and Bob would use an
  asymmetric cryptosystem?
\end{AZtcb}

The most basic part of designing \textit{secure} \ix{asymmetric cryptosystem}s
is that \textbf{it must be infeasible for Eve to compute the decryption key
$k_d$ even when she knows the [public] encryption key\index{encryption key [for an asymmetric cryptosystem]}\index{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]} $k_e$}.  After all, the
encryption key is public, so if it were feasible to do this calculation, Eve
would simply do that and be able to decrypt all ciphertexts herself.

Another consideration for the security of these systems is that the space of
possible decryption keys must be very large.  Otherwise, Eve could simply do the
\ix{brute-force attack} of trying all of the possible decryption keys.

Actually, for \ix{asymmetric cryptosystem}s there is another possible
\ix{brute-force attack} which goes like this: If Eve had a pretty good idea
of a fairly small set of possible messages that Alice might be encrypting to
send to Bob, Eve could simply use the public encryption key\index{encryption key [for an asymmetric cryptosystem]}\index{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]} herself and do
all of those encryptions.  If one her guesses for the original message was
correct, then its encryption will be the same as the ciphertext which she saw
on the public network, going from Alice to Bob.  Therefore, the space of
possible messages must be quite large to prevent this kind of
\ix{brute-force attack}.

There is actually a nice way to prevent this message space-based
\ix{brute-force attack}, by making a cleartext message artificially larger
before encrypting it.  One usually does this by adding some
\begin{definition}\label{def:salt}
\textbf{Cryptographic salt}\index{cryptographic salt}\index{salt!cryptographic}
is random data added to a message Alice wants to sent to Bob before she encrypts
it, which is automatically removed at Bob's end, after he decrypts the
ciphertext.
\end{definition}
Once Alice salts her message, if Eve wants to do the message space-based
\ix{brute-force attack}, she must try encrypting all possible messages Alice
might have sent, \textit{plus} all possible random choices of salt.  With even
a relatively modest number of salt bits, this will make this
\ix{brute-force attack} entirely too time-consuming.

\vskip2mm
\begin{AZtcb}[label=az:asymmetricCSattacks]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting?  Do you understand this new, ``message space-based
  \ix{brute-force attack}'' and how
  \ix{cryptographic salt}\index{salt!cryptographic} prevents it?
\end{AZtcb}

One last remark about \ix{key}s and \textit{generating them}, for
\ix{asymmetric cryptosystem}s: Keys for asymmetric cryptosystems are more
delicate than for \ix{symmetric cryptosystem}s.  Typically, one picks a
private/decryption key\index{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]} of a certain size\index{key!size} -- large, to prevent
\ix{brute-force attack}s, and often using strong randomness, also to prevent
brute-force attacks which would be possible if the adversary knew something
about the structure of the keys you are likely to choose.

Then one does a computation using that private/decryption key\index{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]} to create the
corresponding public/encryption key\index{encryption key [for an asymmetric cryptosystem]}\index{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}.  This computation must be very hard to
\textit{undo}, since otherwise Eve could find the private key from knowing its
public key!

Therefore the whole process of key creation can be quite complicated for
\ix{asymmetric cryptosystem}s.  Implementations must have a key
generation\index{key!generation} step which can actually be quite
time-intensive, but which is run only once by the person who wants to be able
to receive encrypted messages from strangers on the 'net.  This is of course
in contrast with the situation of \ix{symmetric cryptosystem}s, where Alice and
Bob simply agree upon some \ix{key} with the correct number of bytes, however
they want, and start encrypting and decrypting right away: there is no special
``\textit{key generation}\index{key!generation}'' step for symmetric
cryptosystems.

\vfill
\pagebreak
\section{Using the RSA asymmetric cryptosystem in Python}
\index{asymmetric cryptosystem}
\index{RSA cryptosystem}\index{cryptosystem!RSA}\label{sec:UtRSAACiP}

One of the oldest and still most widely used\footnote{In a sense, this is unfortunate: to get the same security with RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} as with \ix{elliptic curve cryptosystem}s, much larger keys must be used and so the computations are significantly slower.  The advantage of RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} is probably that it is based on mathematics that is at the level of advanced undergraduates, while elliptic curve cryptosystems are
based on mathematics at the graduate level.} \ix{asymmetric cryptosystem}s is
know as \textbf{RSA}\index{cryptosystem!RSA}\index{RSA cryptosystem}, so named
in honor of its three inventors: Ron \textbf{R}ivest\index{Rivest, Ron},
Adi \textbf{S}hamir\index{Shamir, Adi}, and Leonard
\textbf{A}dleman\index{Adleman, Leonard}.  We're going to use a {\Python}
implementation of RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} to
explore the basic features of using \ix{asymmetric cryptosystem}s such as
key generation\index{key!generation}, \ix{encryption}, and \ix{decryption},
first in an entirely straightforward way that is not entirely secure.  Then we
will revisit these basic functions in a slightly more complex configuration
that is actually secure.

\subsection{Straightforward -- not completely secure! -- RSA in \Python}
\label{ssec:UtRSAaciP_SncsRSAiP}
\index{cryptosystem!RSA}\index{RSA cryptosystem}

The {\Python} module \code{Crypto}\index{Crypto [Python module]@\code{Crypto} [Python module]}\index{Python!Crypto module@\code{Crypto} module} has a submodule \code{Crypto.PublicKey}\index{Crypto [Python module]@\code{Crypto} [Python module]!Crypto.PublicKey@\code{Crypto.PublicKey}}\index{Python!Crypto.PublicKey module@\code{Crypto.PublicKey} module}
which implements a class \code{RSA}\index{Crypto.PublicKey [Python module]@\code{Crypto.PublicKey} [Python module]!RSA@\code{RSA}}\index{Python!RSA class in Crypto.PublicKey module@\code{RSA} class in \code{Crypto.PublicKey} module}\index{RSA [Python class in Crypto.PublicKey module]@\code{RSA} [Python class in \code{Crypto.PublicKey} module]}.  You can use this class by the usual\\
\begin{codedisp}
from Crypto.PublicKey import RSA
\end{codedisp}

The first thing to do with an \code{RSA} object is to generate a new one,
using\index{Crypto.PublicKey [Python module]@\code{Crypto.PublicKey} [Python module]!RSA@\code{RSA}}\index{Python!RSA class in Crypto.PublicKey module@\code{RSA} class in \code{Crypto.PublicKey} module}\index{RSA [Python class in Crypto.PublicKey module]@\code{RSA} [Python class in \code{Crypto.PublicKey} module]}\\
\begin{codedisp}
key=RSA.generate(n)
\end{codedisp}

\noindent where \code{n} is the number of bits in (part of) the key.  The
values allowed for this parameter must be at least 1024, and must be a
multiple of 256.

As is often the case, the larger the key, the more secure is the cryptosystem
but the slower are the calculations to generate the
key\index{key!generation!RSA} and also to do \ix{encryption} and
\ix{decryption}.  Common values one sees in use today are 1024 and 2048,
although also 4096 is not unusual.

\vskip2mm
\begin{CTtcb}[label=ct:timingRSAkeygen]{}{}
Write a \Python\ function \code{timeRSAkeygen(n)} which takes as input a
\ix{key} size\index{key!size} \code{n} and generates 100 RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} \ix{key}s of that size\index{key!size}.  Time how long each
key generation takes, using the approach to measuring execution time in Code
Task~ \ref{ct:howfastAES}, and append that new execution time to a list.
\code{timeRSAkeygen(n)} should then return the average of that list of
100 times.

Then run that program \code{timeRSAkeygen(n)} for the \ix{key} sizes\index{key!size} which start
at 1024 and go up to 4096 in steps of 256 -- that is, for values of \code{n}
ranging over the list \code{[x for x in range(1024,4097,256)]} --  and print
out for each \ix{key} size\index{key!size} the average key generation time produced by
\code{timeRSAkeygen(n)} for that \ix{key} size\index{key!size}.
\end{CTtcb}

\vskip2mm
\begin{BTtcb}[label=bt:timingRSAkeygenplot]{}{}
Make a plot of the timing information you just gathered.  That is,
for each key length, you computed the average amount of time it took per
generation of a key\index{key!generation!RSA} of that size\index{key!size} over 100 times.  Now
make a line plot where the $x$ values are those \ix{key} sizes\index{key!size} and the corresponding
$y$ values are the average key generation\index{key!generation} times for that size key\index{key!size}.  Make sure
your graph has a title and $x$- and $y$-axis labels.

If you are not familiar with making simple line plots in \Python, just do a
search for ``{\tt python line plot}'' and there will be literally hundreds of
pages with quick-start guides to making line plots with
\code{matplotlib.pyplot}\index{matplotlib.pyplot@\code{matplotlib.pyplot}},
many including code that you can copy and easily adapt.
\end{BTtcb}

Let's look at one of those keys generated with
\code{RSA.generate}\index{key!generation!RSA}, using a method
\code{exportKey}\footnote{This method may be called \code{export\_key} if you
are using a different version of the \code{Crypto}\index{Crypto [Python module]@\code{Crypto} [Python module]}\index{Python!Crypto module@\code{Crypto} module} module.} of the \code{RSA}\index{Crypto.PublicKey [Python module]@\code{Crypto.PublicKey} [Python module]!RSA@\code{RSA}}\index{Python!RSA class in Crypto.PublicKey module@\code{RSA} class in \code{Crypto.PublicKey} module}\index{RSA [Python class in Crypto.PublicKey module]@\code{RSA} [Python class in \code{Crypto.PublicKey} module]} class:\\

\vskip2mm
\begin{adjustbox}{center}
\begin{codedisp}
>>> from Crypto.PublicKey import RSA
>>> key = RSA.generate(1024)
>>> key.exportKey()
b'-----BEGIN RSA PRIVATE KEY-----\nMIICXQIBAAKBgQDRpxdIHxJTp
uM3R/mHKurOrAXnJ5a/nlucxvst3lpHVcs9Yv+Q\nTTtOrDVvgs7BBq2pdjO
DOYxEmAX2GGDuJIFMKZ8Se2ZUGWeJZ0sJolUoANQ0ihIj\nD7zvFz40kuWLU
7imSMOlQpWk35lyN2BR4I6DvAo6f4JKzEJ1l2wuig+75QIDAQAB\nAoGAQsK
HamLijhq1fdQAhGdJMBidJJd5rHj7yTefomKMsuyB9IFCyiuduBakSWcI\n+
XRr9mt6Sc4YeXtDYrMuooajWQ6Ltg8sGqjpDtrYzPILiVgN8fXz1R2TKAePr
ZUO\nKazRnkMN6QcgX1xilfXFtr3Q2OB67dpnVwK3mtAI3E6tZ4ECQQDZWho
gDB3+xkkO\nES0mH0DtyeEbLSknAF84/xSylD58vVYvwWGma4dHEmZcjKEob
c8dQQrndBm8jVQS\niDblKjhhAkEA9u6EZfk+JqeuoUleirRI5X1Kwvy8jo7
7kEf3noVBE3Eve9eJgcX2\nO+ZrAWke3tKqqu6+Tdy9AKkgl1s5EdfiBQJBA
K3My7k2l0Gj4sT53SVvtmaumG83\nxIFoXbxg1Hcb7X+nkuRq+R+vOiQNxYZ
Z+YAvln8pBIQhpXbNeB29iE/lW+ECQFWB\nxqshIdp02k3TgD97qnp9ZnQa3
Jho/se5hA+KiTxYR18VBfLAQEIByjAU3LHANYU3\nYwLHW1NtPXHsDtkU7pk
CQQC4N+Q/IHEY/Sc+fvha5x8zdWmGwODheGJ6Q2i6GN+I\n9LvYjKW5hZ1Gi
rUBjonzNi1vrQsaaVZatRsLa1iwTRIa\n-----END RSA PRIVATE KEY-----'
\end{codedisp}
\end{adjustbox}

\vskip3mm
\noindent Notice a couple of things about this:
\begin{itemize}
\item[$\bullet$] Apparently this is a \textbf{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{private key}\index{decryption key [for an asymmetric cryptosystem]}: that is,
it is the sort of thing, in an \ix{asymmetric cryptosystem}, that must be kept
secret.
\item[$\bullet$] Also, when one exports a key, it is a byte string.  This
means that if you want to write this to a file, you need to open the file
with a command like\\
\begin{codedisp}
file_handle = open("filename", "wb")
\end{codedisp}

\noindent The \code{"wb"} there means that the file is being opened for
\textbf{w}riting in \textbf{b}yte mode.
\end{itemize}

If you can export a key, it stands to reason that you can also import one.  In
fact, this is quite easy: suppose that \ix{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]} byte string were stored in a variable
\code{exported\_key}.  Then you could make an identical RSA object by\\
\begin{codedisp}
>>> from Crypto.PublicKey import RSA
>>> new_key = RSA.importKey(exported_key)
\end{codedisp}

\noindent and that \code{new\_key} will have all of the properties and uses as
the original \code{key}, above.


\vskip2mm
\begin{CTtcb}[label=ct:saveRSAprivatekey]{}{}
Write a \Python\ function \code{gen\_save\_RSA\_private(n, name)} which
takes as input a \ix{key} size\index{key!size} \code{n} and a string \code{name}.  The function
should generate an RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} \ix{key} of
size\index{key!size} \code{n} and store it in a file with the given \code{name}.  It should also
return that instance.

Then write a \Python\ function \code{recall\_RSA\_private(name)} which takes
as input a string \code{name}.  It should open the file with that \code{name},
create an instance of the RSA\index{Crypto.PublicKey [Python module]@\code{Crypto.PublicKey} [Python module]!RSA@\code{RSA}}\index{Python!RSA class in Crypto.PublicKey module@\code{RSA} class in \code{Crypto.PublicKey} module}\index{RSA [Python class in Crypto.PublicKey module]@\code{RSA} [Python class in \code{Crypto.PublicKey} module]} class with the key value stored in that file, and it should
return that instance.

The ideas is that you should be able to use these functions in situations
like:\\
\begin{codedisp}
>>> from Crypto.PublicKey import RSA
>>> key = gen_save_RSA_private(1024, "AliceRSA")
>>> # do lots of encryption and decryption with this key
>>> # ... then take a break and even quit Python and
>>> # reboot the computer
>>> # ... but eventually restart the computer and Python
>>> # and do this:
>>> from Crypto.PublicKey import RSA
>>> key = recall_RSA_private("AliceRSA")
>>> # and then lots more encryption and decryption with
>>> # the same key [identity] as before
\end{codedisp}
\end{CTtcb}

As we mentioned near the end of \S\ref{sec:UtRSAACiP}, in an
\ix{asymmetric cryptosystem}, first one computes the \ix{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]} and then, from the private key,
one computes the corresponding \ix{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]}.  In fact, as was also mentioned, it is important for
the security of the \ix{asymmetric cryptosystem} that while computation
$$
\boxed{\mathrm{private\ key}}\quad\rightsquigarrow\quad\boxed{\mathrm{public\ key}}
$$
can be done in a reasonable amount of time -- it doesn't have to be fast,
though, since it will be done only once, when setting up the cryptosystem --
the computation backwards
$$
\boxed{\mathrm{private\ key}}\quad\leftsquigarrow\quad\boxed{\mathrm{public\ key}}
$$
must be entirely impractical no matter how great are the computational resources
available to the enemies that it is imagined will try to break this secure
communication.

In the case of RSA\index{cryptosystem!RSA}\index{RSA cryptosystem}, the
easy direction of from private\index{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]} to \ix{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]} is just \textit{multiplication} and the hard, backwards
direction is basically just \textit{division}.  As most of us remember from
grade school, it is much easier and more direct to multiply two numbers than
it is to divide two.  For RSA\index{cryptosystem!RSA}\index{RSA cryptosystem},
the two numbers one multiplies are \textbf{\ix{prime numbers}}, meaning that
they are numbers which have no positive, whole number factors other than one
and themselves.  Multiplication of primes is still just as easy (and fast) as
for any other types of numbers, even if they are hundreds of digits long.
However, if you are given a 600 digit number and told that it is the product
of two 300 digit primes, then it would take an immense amount of time -- a
sizeable fraction of the age of the universe: \textit{really an immense amount
of time} -- using the best algorithms and hardware we have today to find those
primes.

It is, however, not a mathematical theorem (at this time) that there cannot be
some great factorization algorithm out there, as yet undiscovered, which
would make the step 
$$
\boxed{\mathrm{private\ key}}\quad\leftsquigarrow\quad\boxed{\mathrm{public\ key}}
$$
relatively fast for RSA\index{cryptosystem!RSA}\index{RSA cryptosystem}, the
most widely used \ix{asymmetric cryptosystem} on the planet right now.  That
may or may not make you uncomfortable....\footnote{And it may or may not make
you even more uncomfortable to learn that \textbf{\ix{quantum computer}s} --
computers which can do a kind of general-purpose computation in a different
model of what that means, based on \ix{quantum mechanics} -- \textit{do} have
a fast factorization algorithm.  RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} may well be broken the minute the first
real, full-sized \ix{quantum computer} is turned on!}

\vskip2mm
\begin{AZtcb}[label=az:RSAfactoring]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting?  Do you understand how
  RSA\index{cryptosystem!RSA}\index{RSA cryptosystem}'s security could rely
  upon how it is easy to multiply but hard to divide [factor]?
\end{AZtcb}

Regardless of these general considerations around the security of
RSA\index{cryptosystem!RSA}\index{RSA cryptosystem}, since it is a working
\ix{asymmetric cryptosystem}, there must be a way to get just that
\ix{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]} from
the \ix{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]} in
\Python.  Here's how (continuing from an example given above):\\
\vskip2mm
\begin{adjustbox}{center}
\begin{codedisp}
>>> from Crypto.PublicKey import RSA
>>> key = RSA.generate(1024)
>>> key.exportKey()
b'-----BEGIN RSA PRIVATE KEY-----\nMIICXQIBAAKBgQDRpxdIHxJTpuM3
R/mHKurOrAXnJ5a/nlucxvst3lpHVcs9Yv+Q\nTTtOrDVvgs7BBq2pdjODOYxEm
AX2GGDuJIFMKZ8Se2ZUGWeJZ0sJolUoANQ0ihIj\nD7zvFz40kuWLU7imSMOlQp
Wk35lyN2BR4I6DvAo6f4JKzEJ1l2wuig+75QIDAQAB\nAoGAQsKHamLijhq1fdQ
AhGdJMBidJJd5rHj7yTefomKMsuyB9IFCyiuduBakSWcI\n+XRr9mt6Sc4YeXtD
YrMuooajWQ6Ltg8sGqjpDtrYzPILiVgN8fXz1R2TKAePrZUO\nKazRnkMN6QcgX
1xilfXFtr3Q2OB67dpnVwK3mtAI3E6tZ4ECQQDZWhogDB3+xkkO\nES0mH0Dtye
EbLSknAF84/xSylD58vVYvwWGma4dHEmZcjKEobc8dQQrndBm8jVQS\niDblKjh
hAkEA9u6EZfk+JqeuoUleirRI5X1Kwvy8jo77kEf3noVBE3Eve9eJgcX2\nO+Zr
AWke3tKqqu6+Tdy9AKkgl1s5EdfiBQJBAK3My7k2l0Gj4sT53SVvtmaumG83\nx
IFoXbxg1Hcb7X+nkuRq+R+vOiQNxYZZ+YAvln8pBIQhpXbNeB29iE/lW+ECQFWB
\nxqshIdp02k3TgD97qnp9ZnQa3Jho/se5hA+KiTxYR18VBfLAQEIByjAU3LHAN
YU3\nYwLHW1NtPXHsDtkU7pkCQQC4N+Q/IHEY/Sc+fvha5x8zdWmGwODheGJ6Q2
i6GN+I\n9LvYjKW5hZ1GirUBjonzNi1vrQsaaVZatRsLa1iwTRIa\n-----END
RSA PRIVATE KEY-----'
>>> public_key = key.publicKey()
>>> public_key.exportKey()
b'-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBi
QKBgQDRpxdIHxJTpuM3R/mHKurOrAXn\nJ5a/nlucxvst3lpHVcs9Yv+QTTtOrD
Vvgs7BBq2pdjODOYxEmAX2GGDuJIFMKZ8S\ne2ZUGWeJZ0sJolUoANQ0ihIjD7z
vFz40kuWLU7imSMOlQpWk35lyN2BR4I6DvAo6\nf4JKzEJ1l2wuig+75QIDAQAB
\n-----END PUBLIC KEY-----'
\end{codedisp}
\end{adjustbox}

\vskip2mm
\noindent If you use this \ix{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]} byte string in an \code{RSA.importKey} then it will work, but
it will build an instance of the RSA\index{Crypto.PublicKey [Python module]@\code{Crypto.PublicKey} [Python module]!RSA@\code{RSA}}\index{Python!RSA class in Crypto.PublicKey module@\code{RSA} class in \code{Crypto.PublicKey} module}\index{RSA [Python class in Crypto.PublicKey module]@\code{RSA} [Python class in \code{Crypto.PublicKey} module]} class which only has the \ix{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]} and so can do encryption but not
decryption.  This is the kind of RSA\index{Crypto.PublicKey [Python module]@\code{Crypto.PublicKey} [Python module]!RSA@\code{RSA}}\index{Python!RSA class in Crypto.PublicKey module@\code{RSA} class in \code{Crypto.PublicKey} module}\index{RSA [Python class in Crypto.PublicKey module]@\code{RSA} [Python class in \code{Crypto.PublicKey} module]} key object which most users will be building to
send encrypted messages to the owner of the \ix{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]}, while the full, original RSA\index{Crypto.PublicKey [Python module]@\code{Crypto.PublicKey} [Python module]!RSA@\code{RSA}}\index{Python!RSA class in Crypto.PublicKey module@\code{RSA} class in \code{Crypto.PublicKey} module}\index{RSA [Python class in Crypto.PublicKey module]@\code{RSA} [Python class in \code{Crypto.PublicKey} module]} key object with both
private\index{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]} and \ix{public key}s\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]}
should only be known to and used by the person receiving and decrypting those
messages.

\vskip2mm
\begin{CTtcb}[label=ct:saveRSApublickey]{}{}
Do a version of Code Task~\ref{ct:saveRSAprivatekey} which also saves the
\ix{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]} in a
separate file.  That is, make a \Python\ function
\code{gen\_save\_RSA\_pub\_priv(n, name)} which takes as input a \ix{key} size\index{key!size}
\code{n} and a string \code{name}.  The function should generate an
RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} \ix{key}\index{key!size} of size \code{n} and
store it in a file with name \code{name+".private"}.  It should also store just
the corresponding
\ix{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]} in
a file with name \code{name+".public"}.  Finally, it should return the
full instance (not just the public version).

Then write a \Python\ function \code{recall\_RSA\_public(name)} which takes as
input a string \code{name}.  It should open the file with name
\code{name+".public"}, create an instance of the RSA\index{Crypto.PublicKey [Python module]@\code{Crypto.PublicKey} [Python module]!RSA@\code{RSA}}\index{Python!RSA class in Crypto.PublicKey module@\code{RSA} class in \code{Crypto.PublicKey} module}\index{RSA [Python class in Crypto.PublicKey module]@\code{RSA} [Python class in \code{Crypto.PublicKey} module]} class with the key value stored in
that file, and it should return that instance.

The idea is that you should be able to use these functions in situations
like:\\
\begin{codedisp}
>>> # Bob does:
>>> from Crypto.PublicKey import RSA
>>> key = gen_save_RSA_pub_priv(1024, "BobRSA")
>>> # then puts the file "BobRSA.public" on an open
>>> # website, where Alice could download it
>>> # ... then, with this file on her machine,
>>> # Alice can do:
>>> from Crypto.PublicKey import RSA
>>> public_key = recall_RSA_public("BobRSA.public")
>>> # and Alice can encrypt using this new
>>> # public key and send messages which only Bob
>>> # will be able to decrypt using his original
>>> # key which has both public and private keys
\end{codedisp}
\end{CTtcb}

We still haven't used these RSA\index{Crypto.PublicKey [Python module]@\code{Crypto.PublicKey} [Python module]!RSA@\code{RSA}}\index{Python!RSA class in Crypto.PublicKey module@\code{RSA} class in \code{Crypto.PublicKey} module}\index{RSA [Python class in Crypto.PublicKey module]@\code{RSA} [Python class in \code{Crypto.PublicKey} module]} key objects to encrypt and decrypt messages.  Remember, it
is an object like the \code{public\_key} one in the example above which is all
that is needed to do encryption (we use the same key as above, rather than
generating a new one, just for consistency), which we could create with\\
\vskip1mm
\noindent\begin{adjustbox}{center}
\begin{codedisp}
>>> from Crypto.PublicKey import RSA
>>> public_key = RSA.importKey(b'-----BEGIN PUBLIC KEY-----\nMIGf
MA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDRpxdIHxJTpuM3R/mHKurOrAXn\nJ5a
/nlucxvst3lpHVcs9Yv+QTTtOrDVvgs7BBq2pdjODOYxEmAX2GGDuJIFMKZ8S\ne2
ZUGWeJZ0sJolUoANQ0ihIjD7zvFz40kuWLU7imSMOlQpWk35lyN2BR4I6DvAo6\nf
4JKzEJ1l2wuig+75QIDAQAB\n-----END PUBLIC KEY-----')
\end{codedisp}
\end{adjustbox}

\vskip3mm
\noindent We can then use the \code{encrypt} method of this \code{public\_key}
object to do encryption.  But note first that \code{encrypt} has a second
argument, just for backwards compatibility with earlier versions of this
module, which must be some long integer that is actually completely ignored.
Notice also that the return value of \code{encrypt} is a tuple, the first
element of which is the byte string of the ciphertext, so:\\
\vskip3mm
\noindent\begin{adjustbox}{center}
\begin{codedisp}
>>> ciphertext = public_key.encrypt(b'This is a test',1)[0]
>>> print(ciphertext)
b'\xbfa\xb0\x8b\x08*\xdf\x96gK0B/\xa2\x8e\x1e\x86\xf2]8\xd9\xc
b\xc2w\xad\x82}\xb5\xf4\x97\xe1g\x91\xc8\x00\x14fr\x15\xc1\x8b
\xbd\x8di\x1f\xbc\tt\x8f\xfa\x1c\xad\xb8V\xca\xc7\xed\xb3X"\xb
7ra\xf8h\x01\x94c\xc9\xaf\xf6\xd5\x0f/\x83[\xea\xfd\x85\xdep9\
xf2\xee\xfc\xec\xd7\xfc\xfd\xe0\xf1\xcc\x12\x8fZ\xad\xf0|n@\xe
8vD\xb48}a\xd8^\xdb#\xbb\x01\x8e\x8c\x1a;[\x8e\xfd@\xc1\xb8Ohw
\xc4\x15'
\end{codedisp}
\end{adjustbox}

\vskip2mm
As we mentioned above, this \code{public\_key} object cannot do decryption.
In fact, if you try it, you will get some error like\\

\noindent\begin{adjustbox}{center}
\begin{codedisp}
>>> public_key.decrypt(ciphertext)
Traceback (most recent call last):
  File " &lt;stdin>", line 1, in  &lt;module>
  File "/usr/lib/python3/dist-packages/Crypto/PublicKey/RSA.py
", line 174, in decrypt
    return pubkey.pubkey.decrypt(self, ciphertext)
  File "/usr/lib/python3/dist-packages/Crypto/PublicKey/pubkey
.py", line 93, in decrypt
    plaintext=self._decrypt(ciphertext)
  File "/usr/lib/python3/dist-packages/Crypto/PublicKey/RSA.py
", line 239, in _decrypt
    mp = self.key._decrypt(cp)
TypeError: Private key not available in this object
\end{codedisp}
\end{adjustbox}

\vskip2mm
On the other hand, if we still had the \code{key} object around, which contained
the \ix{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]} --
or if we saved off the exported version of that key into a file and then
rebuilt \code{key} with \code{RSA.importKey} on the byte string in that file --
then we could do decryption as simply as\\
\begin{codedisp}
>>> key.decrypt(ciphertext)
b'This is a test'
\end{codedisp}

\vskip2mm
\begin{CTtcb}[label=ct:howfastRSA]{}{}
Do a version of Code Task~\ref{ct:howfastAES} for the
RSA\index{cryptosystem!RSA}\index{RSA cryptosystem}.

That is, make a new RSA\index{Crypto.PublicKey [Python module]@\code{Crypto.PublicKey} [Python module]!RSA@\code{RSA}}\index{Python!RSA class in Crypto.PublicKey module@\code{RSA} class in \code{Crypto.PublicKey} module}\index{RSA [Python class in Crypto.PublicKey module]@\code{RSA} [Python class in \code{Crypto.PublicKey} module]} \code{key} object of \ix{key} size\index{key!size} 1024.  Pick a random cleartext of
length around 100 bytes.  Then encrypt it 100 times with \code{key.encrypt} and
report on the average time it takes to do the encryption (using the timing
method described in Code Task~\ref{ct:howfastAES}).

Likewise take the ciphertext coming from any of those encryptions with
\code{key} and do 100 decryptions of that ciphertext, reporting on the average
time it takes to do the decryption.
\end{CTtcb}

\vskip2mm
\begin{CTtcb}[label=ct:diffusionRSA]{}{}
 Do a version of Code Task~\ref{ct:diffusionAES} for
 RSA\index{cryptosystem!RSA}\index{RSA cryptosystem}.

 That is, make a new RSA\index{Crypto.PublicKey [Python module]@\code{Crypto.PublicKey} [Python module]!RSA@\code{RSA}}\index{Python!RSA class in Crypto.PublicKey module@\code{RSA} class in \code{Crypto.PublicKey} module}\index{RSA [Python class in Crypto.PublicKey module]@\code{RSA} [Python class in \code{Crypto.PublicKey} module]} \code{key} object of \ix{key} size\index{key!size} 1024.  Pick a cleartext you like of
 length around 80 or 100 bytes.  Make two versions of the cleartext which
 differ by only one bit.

 Encrypt both versions of the cleartext with \code{key.encrypt} and use your
 program \code{bits\_diff\_display} from Code
 Task~\ref{ct:bit_difference_checker} to see where and how much the two
 ciphertexts differ.

 You might also try the above for several different keys, just to make sure that
 it's not a fluke which is special for the choice of key you happened to make.
\end{CTtcb}

\vskip2mm
\begin{AZtcb}[label=az:RSAinPython]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting?  Do you feel comfortable using \Python's implementation
  of the RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} cryptosystem?
\end{AZtcb}

\vskip1cm
\subsection{More secure RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} in {\Python} using OAEP\index{Optimal Asymmetric Encryption Padding [OAEP]}\index{OAEP, Optimal Asymmetric Encryption Padding} and PKCS~\#1\index{PKCS \#1, Public Key Cryptography Standard \#1}\index{Public Key Cryptography Standard \#1, PKCS \#1}}
\label{ssec:UtRSAaciP_MSRSAiPuOAEP}

Unfortunately, the direct use of RSA\index{cryptosystem!RSA}\index{RSA cryptosystem}, as we just did, is not considered secure.  This is for several reasons,
some to do with the special structure of RSA\index{cryptosystem!RSA}\index{RSA cryptosystem}, some simply to do with the fact that the bare RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} we used above
has no salt\index{cryptographic salt}\index{salt!cryptographic} and so always
encrypts the same cleartext to the same ciphertext, when using the same key --
for (some) details, see the section \bhref{https://en.wikipedia.org/wiki/RSA_(cryptosystem)\#Attacks_against_plain_RSA}{Attacks against plain RSA} in the \bhref{https://wikipedia.org}{Wikipedia} article \bhref{https://en.wikipedia.org/wiki/RSA_(cryptosystem)}{RSA (cryptosystem)}.

The cryptographic community has developed a theoretical structure which protects
against these attacks on plain RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} called \textbf{\ix{Optimal Asymmetric Encryption Padding [OAEP]}}\index{OAEP, Optimal Asymmetric Encryption Padding}.  OAEP was incorporated into a standard
called \textbf{\ix{PKCS \#1, Public Key Cryptography Standard \#1}}\index{Public Key Cryptography Standard \#1, PKCS \#1}, issued by \ix{RSA Laboratories}, an
American IT security firm founded by the very same Rivest\index{Rivest, Ron},
Shamir\index{Shamir, Adi}, and Adleman\index{Adleman, Leonard} who created the
RSA cryptosystem\index{cryptosystem!RSA}\index{RSA cryptosystem}.  It is
PKCS~\#1\index{PKCS \#1, Public Key Cryptography Standard \#1}\index{Public Key Cryptography Standard \#1, PKCS \#1} that is considered safe to use in
practice\footnote{at least with large enough \ix{key} sizes\index{key!size}, and until someone turns
on a fully functional \ix{quantum computer}}.

PKCS~\#1\index{PKCS \#1, Public Key Cryptography Standard \#1}\index{Public Key Cryptography Standard \#1, PKCS \#1} is implemented in {\Python} with a class
\code{PKCS1\_OAEP}\index{PKCS1\_OAEP [Python class]@\code{PKCS1\_OAEP} [Python class]}\index{Python!PKCS1\_OAEP class@\code{PKCS1\_OAEP} class} in the
\code{Crypto.Cipher}\index{Crypto [Python module]@\code{Crypto} [Python module]!Crypto.Cipher@\code{Crypto.Cipher}}\index{Python!Crypto.Cipher module@\code{Crypto.Cipher} module} module.  Since it is essentially just a padding for an
\ix{asymmetric cryptosystem} -- the ``P'' in ``OAEP''\index{Optimal Asymmetric Encryption Padding [OAEP]}\index{OAEP, Optimal Asymmetric Encryption Padding} --
we make a PKCS \#1 cipher object by feeding it an RSA key object:\\

\begin{adjustbox}{center}
\begin{codedisp}
>>> # Bob does:
>>> from Crypto.PublicKey import RSA
>>> key = gen_save_RSA_pub_priv(1024, "BobRSA")
>>> # then puts the file "BobRSA.public" on an open website
>>> # ... then, Alice gets this file on her machine, and does:
>>> from Crypto.PublicKey import RSA
>>> public_key = recall_RSA_public("BobRSA.public")
>>> from Crypto.Cipher import PKCS1_OAEP
>>> cipher_for_encryption = PKCS1_OAEP.new(public_key)
>>> # and Alice can encrypt messages, e.g.,
>>> cleartext = b'This is a test. This is only a test.'
>>> ciphertext = cipher_for_encryption.encrypt(cleartext)
>>> print(ciphertext)
b'\x17\xf4\xaa\xc8\x84\xa9\xe5\x7f8\xa7\x86`\xea\x13\x1c\x1d>d\
xd5\xaeI\xed\xf8~$Y\xa3\x7f\xb7h\x14W\x1a\x99\\\xdd]P\x08\x0f*\
xd4z\xc2u-\xd6\xbb\xf3\xe2;\xf6\xdaZ\xc9!0-\xce\xa1S\xb4\xcc%,\
x08\x0c#\x00v\x87Kn41\x84\xc8\x18\xdf\xc9\xd8\x83?\xb5\xce\xbf\
x9b&lt;\xadr.6xa\xa8\xad\xca\x0c\x1b\xf4\xc3\x8c\xe0\x05\\U\xc3\x0
b\xdf\x02\xfdk*l\xa3*\xa5>\x7f\xcd\xfa\xb3\xdb\x91\xfd\xd5\x15\
x8b'
>>> # Bob, on his machine, where he the key object which also
>>> # contains the private key, can do decryption by
>>> from Crypto.Cipher import PKCS1_OAEP
>>> cipher_for_decryption = PKCS1_OAEP.new(key)
>>> cleared_text = cipher_for_decryption.decrypt(ciphertext)
>>> print(cleared_text)
b'This is a test. This is only a test.'
\end{codedisp}
\end{adjustbox}

\vskip3mm
\noindent Notice a couple of things about this:
\begin{itemize}
\item[$\bullet$] If you, dear reader, type exactly the same commands into your
computer, you will still get back the original cleartext when you do the
decryption, but the intermediate step of the ciphertext you will get will be
different from the one shown above.  The reason for this is that OAEP\index{Optimal Asymmetric Encryption Padding [OAEP]}\index{OAEP, Optimal Asymmetric Encryption Padding} includes some \ix{cryptographic salt}\index{salt!cryptographic}, so that every time you do encryption, even of the same cleartext, you get a
different ciphertext.  (This is \textbf{a good thing}, it increases security.)
\item[$\bullet$] You cannot encrypt cleartexts which are very large with the
approach described above.  So in a practical situation, one must either break
up a long message into small chunks and encrypt each of them, or else use some
other approach which avoids the size limit.  The second of these solutions
will be described in the very next section, below.
\end{itemize}

As you can probably guess, it makes sense now to see if this new, more secure
version of RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} is slow or fast,
and if it satisfies Shannon's\index{Shannon, Claude} \ix{diffusion} condition.

\vskip2mm
\begin{CTtcb}[label=ct:howfastRSAOAEP]{}{}
 Do a version of Code Task~\ref{ct:howfastRSA} for the 
 RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} in the PKCS \#1/OAEP
 version.

 That is, make a new RSA\index{Crypto.PublicKey [Python module]@\code{Crypto.PublicKey} [Python module]!RSA@\code{RSA}}\index{Python!RSA class in Crypto.PublicKey module@\code{RSA} class in \code{Crypto.PublicKey} module}\index{RSA [Python class in Crypto.PublicKey module]@\code{RSA} [Python class in \code{Crypto.PublicKey} module]} \code{key} object of \ix{key} size\index{key!size} 1024.  Use it to make a
 \code{PKCS1\_OAEP}\index{PKCS1\_OAEP [Python class]@\code{PKCS1\_OAEP} [Python class]}\index{Python!PKCS1\_OAEP class@\code{PKCS1\_OAEP} class} cipher object.
 Pick a random cleartext of length around 100 bytes.  Then encrypt it 100 times
 with \code{cipher.encrypt} and report on the average time it takes to do the
 encryption (using the timing method described in Code
 Task~\ref{ct:howfastAES}).

 Likewise take the ciphertext coming from any of those encryptions and do 100
 decryptions of that ciphertext, reporting on the average time it takes to do
 the decryption.
\end{CTtcb}

\vskip2mm
\begin{CTtcb}[label=ct:diffusionRSAOAEP]{}{}
 Do a version of Code Task~\ref{ct:diffusionAES} for the
 RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} in the PKCS \#1/OAEP
 version.

 That is, make a new RSA\index{Crypto.PublicKey [Python module]@\code{Crypto.PublicKey} [Python module]!RSA@\code{RSA}}\index{Python!RSA class in Crypto.PublicKey module@\code{RSA} class in \code{Crypto.PublicKey} module}\index{RSA [Python class in Crypto.PublicKey module]@\code{RSA} [Python class in \code{Crypto.PublicKey} module]} \code{key} object of \ix{key} size\index{key!size} 1024.  Use it to make a
 \code{PKCS1\_OAEP}\index{PKCS1\_OAEP [Python class]@\code{PKCS1\_OAEP} [Python class]}\index{Python!PKCS1\_OAEP class@\code{PKCS1\_OAEP} class} cipher object.
 Pick a cleartext you like of length around 80 or 100 bytes.  Make two versions
 of the cleartext which differ by only one bit.

 Encrypt both versions of the cleartext with \code{cipher.encrypt} and use your
 program \code{bits\_diff\_display} from Code
 Task~\ref{ct:bit_difference_checker} to see where and how much the two
 ciphertexts differ.

 You might also try the above for several different keys, just to make sure that
 it's not a fluke which is special for the choice of key you happened to make.

 You might also try just comparing two encryptions made in exactly the same
 way, of exactly the same cleartext, with your program
 \code{bits\_diff\_display} to see that the cryptographic salt which
 OAEP\index{Optimal Asymmetric Encryption Padding [OAEP]}\index{OAEP, Optimal Asymmetric Encryption Padding} uses makes for quite different ciphertexts
 every time you do encryption, even starting from the same cleartext.
\end{CTtcb}

\vskip1cm
\subsection{How to use RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} in
a way that is both fast and secure}
\label{ssec:UtRSAaciP_HtuRSAFandS}

It should have been clear from Code Tasks above that RSA, while it has the
nice features of an \ix{asymmetric cryptosystem} with regards to
key distribution\index{key!distribution} and management\index{key!management},
is very slow.  Additionally, it has the problem that one cannot encrypt large
messages -- although, presumably, one could solve this problem by one of the
\ix{block chaining} methods discussed above.  But there is another approach
which takes advantage of the good features of \ix{asymmetric cryptosystem}s
while avoiding the weaknesses.

For this, one uses the whole approach described in this chapter of
\ix{asymmetric encryption}, including generating a
public\index{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]}
and \ix{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]},
posting the public key on some public website for anyone to use, \emph{etc.}
But rather than doing the entire communication in
RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} (or some other
\ix{asymmetric cryptosystem}, one uses that slow but secure
\ix{asymmetric cryptosystem} to transmit a randomly chosen ``session
key''\index{session!key}\index{key!session}. Then the rest of the communication
is done by some fast, well-chained\index{block chaining}, \ix{block cipher}
(such as  AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)}).

A ``session''\index{session} in this context might consist of some agreed-upon
number of messages, or all of the messages necessary to complete some protocol
(like making a credit card payment on the 'net), or all of the message which are
send before some time limit expires.  Whatever triggers the end of a
\ix{session}, when that happens, a new random session key\index{session!key}\index{key!session} must be generated for further secure communications between
the same parties.

This approach is extremely common on the Internet today.  In fact, most of the
time customers watch a movie over the Internet, this is the way the video
stream is sent to them by the provider.  Providers want to send the video data
in encrypted form, so that their valuable movies cannot be stolen by someone
who is merely observing the packets as they go by on the Internet.  Since
customers probably have never met the providers in person to agree upon a key
for a \ix{symmetric cryptosystem}, it would seem that the providers would have
to use an \ix{asymmetric cryptosystem} for this encrypted video stream -- but
\ix{asymmetric cryptosystem}s are too slow to run video through without the
watching human noticing!  On the other hand, block ciphers like
AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} \textit{are} fast enough.  Since the session key\index{session!key}\index{key!session} negotiation\index{session!key!negotiation}\index{key!session!negotiation} at the beginning of the stream happens in a
fraction of a second, the approach in this section allows for security, without
difficulties of key distribution\index{key!distribution}, but nevertheless using
a fast block cipher (for the entire video stream, after the initial session
key\index{session!key}\index{key!session} was sent using an
\ix{asymmetric cryptosystem}).

Below is a graphical depiction of this approach, assuming that Aragorn wants to
initiate fast and secure communication with Bilbo, even though they have not
met in person to share any key.  Note that once the initial session key\index{session!key}\index{key!session} negotiation\index{session!key!negotiation}\index{key!session!negotiation} is finished, there can be any number of messages coming
from either side until the session ends -- the example in this diagram where
the messages strictly alternate is only one possibility.  In fact, often Aragorn
sends her first two messages to Bilbo and
\textcircled{\tiny{2}}, below) as one, larger, concatenated  message
$c_{k_{AB}} + c_1$ (using the {\Python} notation ``+'' for concatenation of byte
strings), since she does not need to wait for any response from Bilbo
after \textcircled{\tiny{1}} before doing \textcircled{\tiny{2}}.

\ \vskip3mm

\centerline{\large\textbf{Fast and secure, session key-based communication, graphically:}}

\ \vskip4mm
\begin{adjustbox}{center}
  \begin{tabular}{|c|c|c|}
    \hline
    Aragorn & on public network & Bilbo\\
    & (where Gollum is watching) & \\
    \hline
    & \textcircled{\tiny{1}} & generate key pair $(k^B_e,k^B_d)$ for\\
    & & asymmetric cryptosystem $\Aa$;\\
    download $k^B_e$ & $\leftarrowtail\ \ \ $ public encryption key\index{encryption key [for an asymmetric cryptosystem]}\index{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\ $k^B_e\ \ \ \leftarrowtail$ & publish $k^B_e$\\
    \hline
    choose random session key $k_{AB}$ & \textcircled{\tiny{2}} & \\
    for symmetric cryptosystem $\Ss$; & & \\
    encrypt $k_{AB}$ using $\Aa$ with & & \\
    public key $k^B_e$, getting $c_{AB}$; & & \\
    transmit $c_{AB}$ & $\rightarrowtail\ \ \ \Aa$-encrypted session key $c_{AB}\ \ \ \rightarrowtail$ & receive $c_{AB}$;\\
    & & decrypt $c_{AB}$ using $\Aa$ with\\
    & & private key $k^B_d$, getting $k_{AB}$\\
    \hline
    create cleartext message $m_1$;& \textcircled{\tiny{3}} & \\
    encrypt $m_1$ using $\Ss$ with & & \\
    session key $k_{AB}$, getting $c_1$; & & \\
    transmit $c_1$ & $\rightarrowtail\ \ \ \Ss$-encrypted ciphertext  $c_1\ \ \ \rightarrowtail$ & receive $c_1$;\\
     & & decrypt $c_1$ using $\Ss$ with \\
     & & session key $k_{AB}$, getting $m_1$\\
    \hline
    & \textcircled{\tiny{4}} & create cleartext message $m_2$;\\
    & & encrypt $m_2$ using $\Ss$ with \\
    & & session key $k_{AB}$, getting $c_2$; \\
    receive $c_2$; & $\leftarrowtail\ \ \ \Ss$-encrypted ciphertext $c_2\ \ \ \leftarrowtail$ & transmit $c_2$\\
    decrypt $c_2$ using $\Ss$ with & & \\
    session key $k_{AB}$, getting $m_2$ & & \\
    \hline
    create cleartext message $m_3$;& \textcircled{\tiny{5}} & \\
    encrypt $m_3$ using $\Ss$ with & & \\
    session key $k_{AB}$, getting $c_3$; & & \\
    transmit $c_3$ & $\rightarrowtail\ \ \ \Ss$-encrypted ciphertext  $c_3\ \ \ \rightarrowtail$& receive $c_3$;\\
     & & decrypt $c_3$ using $\Ss$ with \\
     & & session key $k_{AB}$, getting $m_3$\\
    \hline
    \multicolumn{3}{|l|}{\quad\qquad\qquad\qquad\qquad$\vphantom{\begin{matrix}1\\1\end{matrix}}${\it etc....}} \\
    \hline
  \end{tabular}\\
\end{adjustbox}

\vskip3mm
\begin{AZtcb}[label=az:sessionbased]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting?  Do you understand how Alice and Bob would use this
  \ix{session}-based approach?
\end{AZtcb}

\vskip3mm
It is important that the session keys\index{key!session} used in the above
scheme come from a good source of randomness.  Fortunately, the {\Python}
module \code{Crypto}\index{Crypto [Python module]@\code{Crypto} [Python module]}\index{Python!Crypto module@\code{Crypto} module} has a submodule \code{Crypto.Random}\index{Crypto [Python module]@\code{Crypto} [Python module]!Crypto.Random@\code{Crypto.Random}}\index{Python!Crypto.Random module@\code{Crypto.Random} module} that implements a method \code{get\_random\_bytes(N)}\index{Crypto.Random [Python module]@\code{Crypto.Random} [Python module]!get\_random\_bytes@\code{get\_random\_bytes}}\index{Python!get\_random\_bytes in Crypto.Random module@\code{get\_random\_bytes} method in \code{Crypto.Random} module}\index{get\_random\_bytes [Python method in Crypto.Random module]@\code{get\_random\_bytes} [Python method in \code{Crypto.Random} module]} which generates a good random byte string
of length \code{N}.  This method should be used when creating session keys.

\vskip4mm
\begin{BTtcb}[label=bt:sessionbasedCS]{}{}
Implement the above, \ix{session}-based approach to fast and secure
communications.

Since we're not interested (at the moment) in the technicalities of publishing
material (such as public keys) on the web or of sending messages over the
Internet, you will have to play the roles of both Aragorn and Bilbo.  Instead
of posting or transmitting files and data, you will just put these things into
files and the next program can read in that file, which, we will imagine, came
off the Internet.

Hoping to keep matters clear, we'll insist that every {\Python} function which
Aragorn should run will have a name that starts with \code{A}, while those to be
run by Bilbo will have names starting with \code{B}.  To enforce this idea of
separation, the methods beginning with \code{A} should only use information
that they create themselves or get out of files on the disk (which is playing
the role of the public Internet in this scenario) with names ending in
\code{.public}, and not internal information from the methods beginning with
\code{B}; and vice-versa for the information used by the \code{B} methods.

Here are the steps you should write code for, labeled to correspond to the
numbers steps in the diagram above, and with the initial of the actor who is
to be imagined to be doing the work in that protocol diagram (\textit{i.e.},
basically the initial tells which column of the diagram is being indicated):
\begin{itemize}
\item[\textbf{B} \textcircled{\tiny{1}}:] 
Write a {\Python} method \code{B\_asym\_keygensend(n)} which takes as input a
\ix{key} size\index{key!size} \code{n}.  The function should
\begin{enumerate}
\item generate an RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} \ix{key}
of size\index{key!size} \code{n}
\item store the full version (public\index{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]} and private\index{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]}) in a file \code{B\_asym\_key.private}, and
\item store just the public\index{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]} key part in a file \code{B\_asym\_key.public} .
\end{enumerate}
Remember, saving data in a file whose name ends in \code{.public} is
``sending'' the file over the public network, in the metaphor
of this problem.  [Note, you can accomplish this in very few lines by just
calling the function \code{gen\_save\_RSA\_pub\_priv(n, name)} from Code
Task~\ref{ct:saveRSApublickey} with the correct arguments!]
\item[\textbf{A} \textcircled{\tiny{2}}:] 
Write a {\Python} method \code{A\_session\_keygensend()} which generates and
``sends'' (puts in a file on disk with a name ending in \code{.public}) a
session key for the AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} cryptosystem. This new method should
\begin{enumerate}
\item use \code{get\_random\_bytes}\index{Crypto.Random [Python module]@\code{Crypto.Random} [Python module]!get\_random\_bytes@\code{get\_random\_bytes}}\index{Python!get\_random\_bytes in Crypto.Random module@\code{get\_random\_bytes} method in \code{Crypto.Random} module}\index{get\_random\_bytes [Python method in Crypto.Random module]@\code{get\_random\_bytes} [Python method in \code{Crypto.Random} module]} to generate a high-quality session key\index{key!session}
$k_{AB}$ of the right size for AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)},
\item encrypt $k_{AB}$ with \code{PKCS1\_OAEP}\index{PKCS1\_OAEP [Python class]@\code{PKCS1\_OAEP} [Python class]}\index{Python!PKCS1\_OAEP class@\code{PKCS1\_OAEP} class} (you can reuse some lines of code from the Code
Tasks~\ref{ct:howfastRSAOAEP} or \ref{ct:diffusionRSAOAEP} for this), and
\item store the resulting ciphertext in a file
\code{encrypted\_session\_key.public}
\item store the unencrypted session key\index{key!session} $k_{AB}$ in a file
\code{A\_session\_key} for later use by the \code{A} methods.
\end{enumerate}
Remember, as discussed immediately before Code Task~\ref{ct:saveRSAprivatekey},
above, that when you want to write encrypted data to a file, you should open
the file the with the command \code{file\_handle = open("filename", "wb")} and
then write the date, as usual, with
\code{file\_handle.write(data\_bytestring)}).
\item[\textbf{B} \textcircled{\tiny{2}}:]
Write a {\Python} method \code{B\_session\_keyreceive()} which reads and
decrypts the session key\index{key!session} which Aragorn just created and
``sent.''  For this, it should
\begin{enumerate}
\item open the file \code{encrypted\_session\_key.public} for reading bytes,
and get its contents,
\item read the key in the file \code{B\_asym\_key.private} (use your
method \code{recall\_RSA\_private} from Code Task~\ref{ct:saveRSAprivatekey} to
do this!),
\item use that \ix{key} object to create a \code{PKCS1\_OAEP}\index{PKCS1\_OAEP [Python class]@\code{PKCS1\_OAEP} [Python class]}\index{Python!PKCS1\_OAEP class@\code{PKCS1\_OAEP} class} cipher object,
\item decrypt the session key\index{key!session} previously read in, and
\item save for later use (the bytes of) the decrypted session
key\index{key!session} in a file \code{B\_session\_key} .
\end{enumerate}
\item[\textbf{A} \textcircled{\tiny{3}}:] 
Write a {\Python} method \code{A\_send\_encrypted\_message(m, n)} which takes as
input a byte string \code{m} (the message), and an int \code{n} (the message
number).  This method should:
\begin{enumerate}
\item open the file \code{A\_session\_key} for reading bytes, and get its
contents,
\item using that key, create a \code{Crypto.Cipher}\index{Crypto [Python module]@\code{Crypto} [Python module]!Crypto.Cipher@\code{Crypto.Cipher}}\index{Python!Crypto.Cipher module@\code{Crypto.Cipher} module} object for AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} in CBC\index{Cipher Block Chaining (CBC) mode block chaining}\index{CBC mode block chaining}\index{block chaining!Cipher Block Chaining (CBC) mode}
mode (as we did in \S\ref{sec:EabaatwAES}),
\item encrypt the message \code{m} using that cipher object,
\item open a file whose name is \code{``c''+str(n)} for writing bytes, and
\item write (the bytes of) the encrypted message to that file.
\end{enumerate}
\item[\textbf{B} \textcircled{\tiny{3}}:] 
Write a {\Python} method \code{B\_receive\_encrypted\_message(n)} which takes as
input an int \code{n} (the message number) and returns the decrypted message.
This method should:
\begin{enumerate}
\item open the file \code{B\_session\_key} for reading bytes, and get its
contents,
\item using that key, create a \code{Crypto.Cipher}\index{Crypto [Python module]@\code{Crypto} [Python module]!Crypto.Cipher@\code{Crypto.Cipher}}\index{Python!Crypto.Cipher module@\code{Crypto.Cipher} module} object for AES\index{Advanced Encryption Standard [AES]}\index{AES (Advanced Encryption Standard)} in CBC\index{Cipher Block Chaining (CBC) mode block chaining}\index{CBC mode block chaining}\index{block chaining!Cipher Block Chaining (CBC) mode}
mode (as we did in \S\ref{sec:EabaatwAES}),
\item open a file whose name is \code{``c''+str(n)} for writing bytes,
\item read (the bytes of) the encrypted message from that file,
\item decrypt the message \code{m} using the previously built cipher object, and
\item return the cleartext.
\end{enumerate}
\item[\textbf{B} \textcircled{\tiny{4}}:] 
Write a {\Python} method \code{B\_send\_encrypted\_message(m, n)} which takes as
input a byte string \code{m} (the message), and an int \code{n} (the message
number).  This method should do exactly the same thing as the
\code{A\_send\_encrypted\_message(m, n)} described above, only switching
\code{A}$\leftrightarrow$\code{B} everywhere.
\item[\textbf{A} \textcircled{\tiny{4}}:] 
Write a {\Python} method \code{A\_receive\_encrypted\_message(n)} which takes as
input an int \code{n} (the message number) and returns the decrypted message.
This method should do exactly the same thing as the
\code{B\_receive\_encrypted\_message(n)} described above, only switching
\code{A}$\leftrightarrow$\code{B} everywhere.
\end{itemize}
[Yes, this seems like a long Task, but it extensively reuses or builds on
other code you've already written, and has very detailed instructions!]
\end{BTtcb}

\vfill
\pagebreak
\section{Digital Signatures}
\index{digital signature}\index{signature!digital}
\label{sec:DS}

The discovery of \ix{asymmetric cryptosystem}s -- or, as they are more often
called in non-technical contexts like this paragraph,
\ix{public-key cryptosystem}s -- has changed the face of the Internet by
allowing secure communications between entities who have never met in real
space to share a secret \ix{key}.  Without this innovation, commerce over
the Internet would be infinitely more difficult, for example.  But beyond
this straightforward application of public-key
crypto\index{public-key cryptosystem} to securing communication against
eavesdroppers, other powerful applications have also been discovered.  A very
nice one, which has many uses in the networked world, is the idea of
\begin{definition}\label{def:digitalsignature}
A \textbf{\ix{digital signature}}\index{signature!digital} is a chunk
$\mathbb S$ of data which accompanies a message $m$.  There is also an
algorithm called \textbf{verifying the signature}\index{signature!digital!verification}\index{verification algorithm [for a digital signature]} which can be run with inputs $\mathbb S$, $m$, and some other public data which, if it returns
{\sc accept}, proves that the signature could only have been produced by
someone who possesses a certain piece of secret data.
\end{definition}

If we make some assumptions about behavior in the real world -- which might or
might not be justified! -- then these
\ix{digital signature}s\index{signature!digital} would have many extremely
valuable applications.  The assumptions we would need include:
\begin{itemize}
\item[$\bullet$] There is some reliable association between the public
information used to verify\index{signature!digital!verification}\index{verification algorithm [for a digital signature]} a signature and the real-world person who claims
they created the signature.  For example, perhaps in order to have the public
information listed on a well-known, trusted site next to a human name, that
human must go to some government office, show an ID, and register their
public data.
\item[$\bullet$] The humans can be trusted to keep the secret data needed to
generate those signatures reliably secure.  For example, the don't keep the
data on a machine which can ever be hacked, and they don't forget to erase it
before they throw out an old hard drive, \textit{etc.}
\end{itemize}

Now for some details.

\vskip1cm
\subsection{Naive digital signatures}
\label{ssec:DS_Ndsw}
\index{digital signature}\index{signature!digital}

It has been important since the beginning of our study of cryptology that
\ix{encryption} and \ix{decryption} are \emph{opposites:} what we would
call ``\ix{inverse functions}'' in mathematics\footnote{\textit{E.g.}, squaring
and taking the square root are inverses (at least if you start with positive
numbers), so that squaring a square root or square rooting a square gives back
the original number.}, meaning that doing first
one and then the other simply gets you back to where you started.  Since
inverse functions work in either order, that means that not only is the
decryption of the encryption of some message just the original message, but
so also is the encryption of the decryption of a message.

That may seem like a mere computational curiosity -- why would anyone
decrypt a message which had not first been encrypted? -- but it actually
has a very nice feature: only the person who has the
\ix{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]} for some
\ix{asymmetric cryptosystem} can do the decryption, while anyone who has
downloaded the corresponding \ix{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]} can do the encryption.  This situation where only the one person
who has some secret information (the \ix{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]}) can do something while everyone else can do some other
thing using a piece of public information (the \ix{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]}) sounds very much like what it supposed to
happen in a \ix{digital signature}\index{signature!digital} scheme.

To be specific, suppose Bilbo wants to be able to digitally
sign\index{digital signature}\index{signature!digital} some message $m$,
and Aragorn wants to be able to verify\index{signature!digital!verification}\index{verification algorithm [for a digital signature]} the signature.  First,
Bilbo should generate\index{key!generation} a public/private\index{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]}\index{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]} key pair and put his public key on his
website.  Then he should use the \ix{decryption} algorithm, with his
\ix{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]}, on the
message $m$, yielding a chunk of data we'll call $s$.  Finally, Bilbo should
send both the message $m$ and the signature $s$ to Aragorn.

Aragorn will have downloaded Bilbo's \ix{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]}.  What he can do is encrypt Bilbo's (purported)
signature $s$, using that \ix{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]}, to get a chunk of data $m^\prime$.  Then Aragorn will \textbf{accept}
the signature as valid if his $m^\prime$ is the same as Bilbo's message $m$.
Since only the person who has Bilbo's \ix{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]} should be able to make a chunk of data $s$ whose
encryption is $m$, this method does implement the
\ix{digital signature}\index{signature!digital} scheme as promised.

Graphically:

\ \vskip2mm
\centerline{\large\textbf{Naive digital signatures:}}

\vskip3mm
\begin{adjustbox}{center}
 \begin{tabular}{|c|c|c|}
  \hline
  Aragorn & on public network & Bilbo\\
   \hline
   & & generate key pair $(k^B_e,k^B_d)$ for \\
   & & asymmetric cryptosystem $\Aa$; \\
   download $k^B_e$ & $\leftarrowtail\ \ \ $ public encryption key\index{encryption key [for an asymmetric cryptosystem]}\index{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\ $k^B_e\ \ \ \leftarrowtail$ & publish $k^B_e$ \\
   \hline
   & & with message $m$: \\
   & & decrypt $m$ using $\Aa$ with \\
   & & private key $k^B_d$, getting $s$; \\
   receive $(m,s)$ & $\leftarrowtail\ \ \ $ signed message\ $(m,s)\ \ \ \leftarrowtail$ & transmit $(m,s)$ \\
   \hline
   encrypt $s$ using $\Aa$ with & & \\
   public key $k^B_e$, getting $m^\prime$; & & \\
   if $m^\prime=m$\qquad\qquad\, & &\\
   {\sc accept}\qquad\  & &\\
   else\qquad\qquad\qquad\ \ & &\\
   \ \ {\sc reject}\qquad\, & &\\
   \hline
 \end{tabular}
\end{adjustbox}

\vskip2mm
\begin{AZtcb}[label=az:naiveDS]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting?  Do you feel comfortable with the way these naive
  \ix{digital signature}s\index{signature!digital} are generated and
  verified\index{signature!digital!verification}\index{verification algorithm [for a digital signature]}?
\end{AZtcb}

\begin{CTtcb}[label=ct:naiveDS]{}{}
 Write a \Python\ function \code{sign(key, m)} which takes as input a
 full (public\index{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]} and private\index{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]})
 \code{key} for RSA\index{cryptosystem!RSA}\index{RSA cryptosystem}, in the
 form of a byte string that might have been produced by \code{exportKey()} and
 a (byte string) message \code{m} and produces the signature \code{s} on
 \code{m} as described above.  To do this, use \code{RSA.importKey} on the
 \code{key} variable to build an RSA\index{Crypto.PublicKey [Python module]@\code{Crypto.PublicKey} [Python module]!RSA@\code{RSA}}\index{Python!RSA class in Crypto.PublicKey module@\code{RSA} class in \code{Crypto.PublicKey} module}\index{RSA [Python class in Crypto.PublicKey module]@\code{RSA} [Python class in \code{Crypto.PublicKey} module]} object.  Use the \code{decrypt} method of this RSA\index{Crypto.PublicKey [Python module]@\code{Crypto.PublicKey} [Python module]!RSA@\code{RSA}}\index{Python!RSA class in Crypto.PublicKey module@\code{RSA} class in \code{Crypto.PublicKey} module}\index{RSA [Python class in Crypto.PublicKey module]@\code{RSA} [Python class in \code{Crypto.PublicKey} module]} object on
 the variable \code{m} to produce the signature \code{s}, which your method
 should return.

 Next, write a \Python\ function \code{verify(pk, m, s)}\index{signature!digital!verification}\index{verification algorithm [for a digital signature]}
 which takes as input a
 \ix{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\index{encryption key [for an asymmetric cryptosystem]}
 \code{pk} for RSA\index{cryptosystem!RSA}\index{RSA cryptosystem}, in
 the form of a byte string that might have been produced by \code{exportKey()},
 a (byte string) message \code{m}, and a (byte string) signature \code{s} on
 that message, and returns a Boolean which indicates if the
 signature\index{digital signature}\index{signature!digital} is valid or not,
 following the scheme above.  To do this, use \code{RSA.importKey} on the
 \code{pk} variable to build an RSA\index{Crypto.PublicKey [Python module]@\code{Crypto.PublicKey} [Python module]!RSA@\code{RSA}}\index{Python!RSA class in Crypto.PublicKey module@\code{RSA} class in \code{Crypto.PublicKey} module}\index{RSA [Python class in Crypto.PublicKey module]@\code{RSA} [Python class in \code{Crypto.PublicKey} module]} object \code{public\_key} and use the \code{encrypt}
 method of \code{public\_key} to create the byte string \code{mprime}.  Don't
 forget that \code{encrypt} takes a second, dummy variable which may as well
 have the value \code{1} and returns a tuple, the 0th element of which is the
 encryption.  In other words, you need to use
 \code{mprime = public\_key(s, 1)[0]}.  Then simply return the (Boolean) value
 of \code{mprime == m} .

 The idea is that you should be able to use these functions in situations like\\
\begin{codedisp}
>>> # Bilbo does:
>>> from Crypto.PublicKey import RSA
>>> key = RSA.generate(1024)
>>> full_key_exported = key.exportKey()
>>> public_key_exported = key.publicKey().exportKey()
>>> # Bilbo puts the public_key_exported on his website
>>> m = b'some message Bilbo wants to sign'
>>> s = sign(full_key_exported, m)
>>> # Bilblo sends (m,s) to Aragorn, maybe by email
>>> # Aragorn downloads the public_key_exported and
>>> # gets an email containing (m,s) and does:
>>> verify(public_key_exported, m, s)
>>> # if it is True, he can trust the message
\end{codedisp}
:
 
\end{CTtcb}

\vskip1cm
\subsection{Better digital signatures using hash functions}
\label{ssec:DS_Ndsuhf}
\index{digital signature}\index{signature!digital}\index{hash functions}

One big problem with the naive \ix{digital signature}s\index{signature!digital}
described above is that they are (potentially) ... big.  That is, the signature
$s$ on a message $m$ is (essentially) the same size as the message itself --
after all, it's a decryption, pretending the message is a ciphertext.  So
signing a large document, or maybe a large database or high-resolution image
would basically require an unacceptable twice the space to store or transmit!

What we need to make much smaller
signatures\index{digital signature}\index{signature!digital} is some sort of
algorithm which essentially \emph{summarizes} the contents of the message $m$
you want to sign.  Then a very similar
signature\index{digital signature}\index{signature!digital} scheme to the one
described above can do its verification algorithm\index{signature!digital!verification}\index{verification algorithm [for a digital signature]} by comparing
the encrypted signature to the summary of the message, rather than to the
entire message.

There's a name for this magical summarizing algorithm:
\begin{definition}
 \label{def:hashfunction}
 A \textbf{cryptographic \ix{hash function}} is an algorithm $H$ which takes as
 inputs bit strings $x$ of arbitrary length and produces outputs $H(x)$ of a
 fixed  size, satisfying the properties:
 \begin{enumerate}
 \item ``\textbf{ease of computation}'' computation of $H(x)$ is very fast;
 \item ``\textbf{\ix{pre-image resistance}}'' starting with any bit string $y$
 of the size of the outputs of $H$, it is very difficult to find a bit string
 $x$ with the property  that $H(x)=y$;
 \item ``\textbf{\ix{second pre-image resistance}}'' starting with any specific
 bit string $x_1$, it is very difficult to find another $x_2$ such that
 $H(x_2)=H(x_1)$;
 \item ``\textbf{\ix{collision resistance}}'' it is very difficult to find any
 two bit strings $x_1$ and $x_2$ such that $H(x_2)=H(x_1)$.
 \end{enumerate}
\end{definition}

In some sense, the key phrase in the above definition is ``very difficult,''
in the sense that there are certainly very many possible inputs to a \ix{hash
function} which give the same output -- in fact, there are an infinite number
of such colliding inputs!  Think about it: if the output size of a \ix{hash
function} is, say, 256 bits, then what happens if you look at input bit
strings of length 257?  There are twice as many input of that size as there
are outputs, so the most efficient possible way to spread out the way the
outputs come from inputs would have every output coming from two inputs!  And
the same argument says there are at least four inputs of length 258 bits
giving the same output, \textit{etc.}  But to be a cryptographic \ix{hash
function}, it must be \emph{very hard} to find such collisions.

In practice, what this means is that the algorithms used for \ix{hash functions}
do a lot of random fiddling around with the bits of their inputs, so there is
not enough structure in the algorithm which might give an attacker a systematic
way to try to find collisions or pre-images or second pre-images.  Without
structure, the only option left would seem to be a \ix{brute-force attack}, but
since there are roughly as many bit strings of length 256 as there are
particles in the universe (leaving out photons and neutrinos, though),
brute-force is not a viable attack.

Cryptographic \ix{hash function}s are useful because if you have a message or
document -- think of it as a bit string $m$ -- the $H(m)$ acts a kind of
fingerprint for $m$.  For example: suppose Bilbo tells Aragorn what $H(m)$ is
without revealing $m$ on Monday, and only on Friday reveals $m$. Aragorn can
be confident that it was the same $m$ Bilbo was thinking of on Monday as he
revealed on Friday, because it would have been ``very difficult'' to find
another $m^\prime$ for which $H(m^\prime)=H(m)$.

\vskip2mm
\begin{AZtcb}[label=az:hashfunction]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting?  Do you feel like you understand what is useful about a
  \ix{hash function}, and why there are theoretically infinitely many
  failures of the conditions \ix{pre-image resistance},
  \ix{second pre-image resistance}, and \ix{collision resistance} but
  nevertheless the fact that it is ``very difficult'' to find those failures
  makes \ix{hash function}s practical?
\end{AZtcb}

There are a number of \ix{hash functions} in use today, and there are some
which were used for a while but which now are no longer considered secure.
As mentioned above, the security of a \ix{hash function} in part rests upon
its lack of structure ... but any algorithm which is clear enough to be written
down and accepted as a standard must have some structure, and eventually
computer scientists have found the way to attack some of the older
\ix{hash function}s using only that little bit of structure.  Here are some
\ix{hash function}s which were or are widely used:
\begin{itemize}
\item[$\bullet$] For around a decade starting in the early 1990s,
the most widely used cryptographic hash function was called
\textbf{\ix{md5}}.  This algorithm was developed by Ron
Rivest\index{Rivest, Ron} and published in 1992.  The output size of
\ix{md5} is 128 bits.

While \ix{md5} was thought to be flawed since the
middle 1990s, a real attack was not published until 2004, when it was shown
not to be collision resistant \cite{wang2005break}.  However,
\ix{md5} is still used extensively today to
verify that a large data transfer has not suffered a transmission error --
{\it i.e.,} it is still a useful tool to test for non-malicious data
corruption.
\item[$\bullet$] The most widely used cryptographic \ix{hash function} from
the late 1990s until recently, and one which is built into many widely
accepted and standardized cryptographic protocols, is \textbf{\ix{SHA-1}},
with an output size of 160 bits.

\ix{SHA-1} was developed by US National Security Agency\index{National Security Agency, NSA}\index{NSA, National Security Agency} in a semi-public
process, and was adopted by the \ix{National Institute of Standards and Technology [NIST]}\index{NIST: National Institute of Standards and Technology}\index{National Institute of Standards and Technology, [NIST]} as part of several US
Federal Information Processing
Standards\index{Federal Information Processing Standards, US}.

In 2004, some work was published which indicated that \ix{SHA-1}
might be vulnerable to certain kinds of attack.  (See \cite{poritz2004hash}.)
For this reason, NIST required in 2010 many US federal data protection
applications to move to another hash function.
\item[$\bullet$] At the time of this writing, most security-conscious users
and organizations recommend \textbf{\ix{SHA-2}}, usually in its
\textbf{\ix{SHA-256}} variant, which has an output size of 256 bits.
Given recent revelations of the NSA's \index{National Security Agency, US [NSA]} involvement -- and weakening of -- cryptographic protocols, it might be a
cause of concern that NSA participated in the development of
\ix{SHA-2}.
\end{itemize}

\ix{SHA-2} is implemented in {\Python} with a class 
\code{SHA256}\index{SHA256 [Python class]@\code{SHA256} [Python class]}\index{Python!SHA256 class@\code{SHA256} class} in the \code{Crypto.Hash}\index{Crypto [Python module]@\code{Crypto} [Python module]!Crypto.Hash@\code{Crypto.Hash}}\index{Python!Crypto.Hash module@\code{Crypto.Hash} module} module.  You can create
this object with \code{SHA256.new(s)}, where \code{s} is the entire byte string
to be hashed\index{hash function}.  Another way use this class, particularly
useful if there is a lot of data to be hashed, is to pass \code{SHA356.new}
the first piece of the data, and the to call the class's \code{update} method
with the remaining pieces of data.

In either approach, when you are done feeding the \code{SHA256}\index{SHA256 [Python class]@\code{SHA256} [Python class]}\index{Python!SHA256 class@\code{SHA256} class} instance your data to be hashed, you can call the \code{digest()}
method to get the hash value as a byte string, or the \code{hexdigest()} method
to get that same hash value as a character string written out in hexadecimal.
For example:

\begin{adjustbox}{center}
\begin{codedisp}
>>> from Crypto.Hash import SHA256
>>> hash_object = SHA256.new(b'first bit of data')
>>> hash_object.update(b'some more data')
>>> hash_object.update(b'last bit of the data')
>>> hash_object.digest()
b':\x93"P`\xd2Y-\x8c/\xab\xfa=\x8e\xa7\xb7N\xdcF\xae[\xf9\xa4\xd
6.\xa1\xfeR\xe4\xcb\x89\xb8'
>>> hash_object.hexdigest()
3a93225060d2592d8c2fabfa3d8ea7b74edc46ae5bf9a4d62ea1fe52e4cb89b8
\end{codedisp}
\end{adjustbox}

\vskip3mm
\noindent Note that you can get the \code{digest} from a \code{SHA256}\index{SHA256 [Python class]@\code{SHA256} [Python class]}\index{Python!SHA256 class@\code{SHA256} class} instance and but still add more data by calling the
\code{update} method and get a later \code{digest} which will be the
\ix{hash function} output for all of the input you've given that instance since
it was created with \code{new}.  What this means is that you must create a new
instance with \code{new} every time you want to start fresh with computing the
\ix{hash function} of a new bit string.

\vskip3mm
\begin{CTtcb}[label=ct:bitdiffsSHA256]{}{}
 Since \ix{SHA256} is believed to have the properties that make it a good
 cryptographic \ix{hash function}, it must be that small changes in the
 input make for drastic changes in the output, 256-bit hash value. In fact,
 the best thing would be for differences of just one bit in the input -- by
 changing a bit, or adding one more bit to the sequence (somewhere: adding it
 at the beginning, end, or somewhere in the middle) to make approximately
 half of the bits in the hash value change. Let's test this!

 First, pick some base input byte string that you like of about 50 bytes.
 Compute its \ix{SHA256} hash value\index{hash function}.  Now try changing
 one bit of this base input, computing the hash value\index{hash function}
 of the new input string, and comparing the two hash values with your
 \code{bits\_diff\_display} from Code Task~\ref{ct:bit_difference_checker} to
 see where and how much the two hashes differ.

 Repeat this several times (at least 10 times), changing bits at different
 locations in the input string, and see each time how much it changes the
 bits of the hash string.  Also compute the average number of bits which were
 changed in the hash value in your experiments.
\end{CTtcb}

As mentioned above, the fact that the cryptographic hash\index{hash function} of
a message is a reliable fingerprint for the message allows us to make a much
more efficient signature\index{digital signature}\index{signature!digital}
scheme.  In this scheme, rather than sending the message and its
\ix{decryption}, we send the message and the decryption of the
hash\index{hash function} of the message.  Therefore the signature is a data
chunk which is as big as the output size of the \ix{hash function} we're using,
no matter how big is the message to be signed.

Graphically:

\vskip2mm
\centerline{\large\textbf{Better [smaller] digital signatures with hashing:}}

\vskip3mm
\begin{adjustbox}{center}
 \begin{tabular}{|c|c|c|}
  \hline
  Aragorn & on public network & Bilbo\\
   \hline
   & & generate key pair $(k^B_e,k^B_d)$ for \\
   & & asymmetric cryptosystem $\Aa$; \\
   download $k^B_e$ & $\leftarrowtail\ \ \ $ public encryption key\index{encryption key [for an asymmetric cryptosystem]}\index{public key}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}\ $k^B_e\ \ \ \leftarrowtail$ & publish $k^B_e$ \\
   \hline
   & & with message $m$: \\
   & & hash $m$ to get $d$; \\
   & & decrypt $d$ using $\Aa$ with \\
   & & private key $k^B_d$, getting $s$; \\
   receive $(m,s)$ & $\leftarrowtail\ \ \ $ signed message\ $(m,s)\ \ \ \leftarrowtail$ & transmit $(m,s)$ \\
   \hline
   encrypt $s$ using $\Aa$ with & & \\
   public key $k^B_e$, getting $d^\prime$; & & \\
   hash $m$ to get $d$; & &\\
   if $d^\prime=d$\qquad\qquad\, & &\\
   {\sc accept}\qquad\  & &\\
   else\qquad\qquad\qquad\ \ & &\\
   \ \ {\sc reject}\qquad\, & &\\
   \hline
 \end{tabular}
\end{adjustbox}

\ \vskip4mm
\begin{AZtcb}[label=az:DSwithhashing]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting?  Do you feel comfortable with how this new approach
  makes a secure \ix{digital signature}\index{signature!digital} scheme,
  because of its structure and the properties of a cryptographic
  \ix{hash function}, which is nevertheless much smaller than the naive
  \ix{digital signature}s\index{signature!digital}?
\end{AZtcb}

\begin{CTtcb}[label=ct:DSwithhashing]{}{}
 Implement this new approach to making \ix{digital signature}s\index{signature!digital} that uses a \ix{hash function} for smaller signatures.

 That is, make new \Python\ functions \code{signH(key, m)} and
 \code{verifyH(pk, m, s)} which have exactly the same inputs and outputs as
 the \code{sign(key, m)} and \code{verify(pk, m, s)} from Code
 Task~\ref{ct:naiveDS} and can be used in the same ways as those original
 functions, but which use \code{SHA256}\index{SHA256 [Python class]@\code{SHA256} [Python class]}\index{Python!SHA256 class@\code{SHA256} class} to
 make signatures which are always quite small.
\end{CTtcb}

\vfill
\pagebreak
\section{Key management and the need for a robust PKI}
\index{key!management}\index{PKI, public key infrastructure}\index{public key infrastructure, PKI}
\label{sec:asymmetricCSs_Km}

We started this chapter by looking for a new approach which might solve a
problem we had with \ix{symmetric cryptosystem}s\index{cryptosystem!symmetric}:
while they are fast and secure, there are many, many situations in which
parties who have never met each other in real life, in a place and situation
where they can share a high quality (meaning: large and hard for others to
guess) secret key, nevertheless want to communicate securely over the Internet.
Asymmetric cryptosystems\index{asymmetric cryptosystem}s\index{cryptosystem!asymmetric} solved this problem by breaking a key into two pieces, one of which
must be kept secret (the \ix{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]}) and one of which must be made public (the \ix{public key}\index{encryption key [for an asymmetric cryptosystem]}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}.

A significant issue with \index{asymmetric cryptosystems}\index{cryptosystem!asymmetric} remains key management\index{key!management}, though: the problem
with Aragorn and Bilbo never meeting in person to set up a shared secret key
is that, basically, they each have to trust each other's websites where their
\ix{public key}s\index{encryption key [for an asymmetric cryptosystem]}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]} must be posted.
If the website is hacked, or even if the communications channel between one
of the participants and the other's website is compromised, then they may end
up using not the public key of their intended message recipient, but rather
a \ix{public key}\index{encryption key [for an asymmetric cryptosystem]}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]} the
hacker has substituted: this is called a
\textit{\ix{person-in-the-middle attack}}\footnote{Although usually a more
gendered term than ``person'' is used.}, and it allows the hackers to read and
even modify all communications between the parties without them even knowing
they have no security!

Graphically, the \ix{person-in-the-middle attack} works like this:

\vskip2mm
\centerline{\large\textbf{Person-in-the-middle attack on
\ix{asymmetric cryptosystem}s:}}
\vskip2mm
\begin{adjustbox}{center}
  \begin{tabular}{|c|c|c|}
    \hline
    Alice & Eve & Bob\\
    \hline
    &  & generate keys: \\
    &  & public $k^B_e$, private $k^B_d$;\\
    & \hphantom{XXXXX}intercept\ \ \ \  $k^B_e\leftarrowtail$ & publish $k^B_e$\\
    \hline
    &  generate keys: & \\
    &  public $k^E_e$, private $k^E_d$; &\\
    download $k^E_e$, thinking it is $k^B_e$ & $\leftarrowtail k^E_e$,\ \ spoof origin\qquad\ &\\
    \hline
    create cleartext message $m_A$; & &\\
    using $k^E_e$, encrypt $m_A$ to $c_A$ & &\\
    and transmit $c_A$ & $\rightarrowtail c_A$, intercept\qquad\quad\  &\\
    \hline
    & using $k^E_d$, decrypt $c_A$ & \\
    & \ \ and recover cleartext $m_A$;\ \ \ & \\
    & read $m_A$, change to $m_E$\, if desired & \\
    & using $k^B_e$, encrypt $m_E$ to $c_E$ &\\
    & \qquad\qquad spoof origin\ \ $c_E\rightarrowtail$ & receive $c_E$, thinking it is $c_A$\\
    \hline
    & & using $k^B_d$, decrypt $c_E$\\
    & &\ \ and recover cleartext $m_E$\ \ \ \\
    & & thinking it is $m_A$ from Alice\\
    \hline
  \end{tabular}
\end{adjustbox}

There is also a \ix{person-in-the-middle attack} on
\ix{digital signature}s\index{signature!digital}, based on similar ideas of
substituting Eve's \ix{public key}\index{encryption key [for an asymmetric cryptosystem]}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]} for Bob's, which we leave to the reader to think through for themself.

\ \vskip3mm
\begin{AZtcb}[label=az:PitMmattack]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting?  Do you feel comfortable with how the
  \ix{person-in-the-middle attack} works, for communications?  What about
  for \ix{digital signature}s\index{signature!digital}?
\end{AZtcb}

\vskip3mm
\begin{BTtcb}[label=bt:PitMsignatures]{}{}
Here's another entirely non-coding Bonus Task:

Write out an explanation of the \ix{person-in-the-middle attack} for
\ix{digital signature}s\index{signature!digital}.  Include a diagram, like the
diagram above called ``Better [smaller] digital signatures with hashing''
crossed with the diagram above called ``Person-in-the-middle
attack\index{person-in-the-middle attack} on \ix{asymmetric cryptosystem}s.''
\end{BTtcb}

\vskip2mm
Apparently, all of the wonders of asymmetric crypto\ix{asymmetric cryptosystem}
will collapse unless we can already be sure that the networks we use and
the websites we visit are never hacked.  That is, unless there is some way
we can have some sort of \textbf{\ix{root of trust}}, a \ix{public key}\index{encryption key [for an asymmetric cryptosystem]}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]} connected to some real-world entity
that we already implicitly trust, and whose security practices we also trust,
so that we can be sure that the \ix{private key}\index{key!private}\index{key!decryption [for an asymmetric cryptosystem]}\index{decryption key [for an asymmetric cryptosystem]} is kept private.

Modern operating systems and browsers come with built-in roots of
trust\index{root of trust}, which the users don't even know about, but which
can be used to verify \ix{digital signature}s\index{signature!digital} signed
by that entity.  Perhaps that entity will have done the work of meeting Jeff
Bezos in real life, and then will issue a
signature\index{digital signature}\index{signature!digital} on Jeff's
\ix{public key}\index{encryption key [for an asymmetric cryptosystem]}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]}.  Then if you
want to use your credit card on \burl{amazon.com}, you can download Amazon's
\ix{public key}\index{encryption key [for an asymmetric cryptosystem]}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]} along with the
root of trust's signature\index{digital signature}\index{signature!digital} on
that key, which will enable you to trust that that the key which seems to be
Amazon's is, in fact, Amazon's.

These \ix{digital signature}s\index{signature!digital} on someone's
\ix{public key}\index{encryption key [for an asymmetric cryptosystem]}\index{key!public}\index{key!encryption [for an asymmetric cryptosystem]} are usually
called \textbf{\ix{certificate}s} and the root of trust, in this context, is
called a \textbf{certificate authority}\index{certificate!authority}.

The broad infrastructure of certificate authorities and public keys which can
be trusted, perhaps because of certificates, to be associated with certain
real-world persons or organizations is called a
\textbf{\ix{public-key infrastructure [PKI]}}\index{PKI, public-key infrastructure}.  If the Internet had a robust, reliable public-key infrastructure\index{[PKI]}\index{PKI, public-key infrastructure}, then we will be able to have
widespread secure communication as well as legally binding (digitally
signed\index{digital signature}\index{signature!digital}) documents on the
web. This, then, is the last manifestation of a persistent issue throughout this
book: key management\index{key!management} is very hard, but very important,
as this necessity of a robust PKI\index{public-key infrastructure [PKI]}\index{PKI, public-key infrastructure} makes clear yet again.

\ \vskip3mm
\begin{AZtcb}[label=az:certificatesPKI]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting?  Do you feel comfortable with the ideas of a root of
  trust (or certificate authority), certificates, and, in general, a PKI?
\end{AZtcb}

\vfill
\pagebreak
\section{Conclusions; consider the blockchain}
\label{sec:asymmetricCSs_Cctb}

At first the idea of an \ix{asymmetric cryptosystem} can seem a bit like magic.
In fact, it must be admitted that the security of all of such cryptosystems in
wide use today is based on assumptions that seem very reasonable but are not
known with mathematical certainty: for example, the security of
RSA\index{cryptosystem!RSA}\index{RSA cryptosystem} is based on the assumption
that it is impossible to factor large numbers in a reasonable amount of time
(for a certain precise meaning of the word ``reasonable'').

(Interestingly, the best known attack on this particular assumption, using
a \ix{quantum computer}, seemed for a long time like science fiction, but now
seems like it definitely will start to be deployed at least by entities such as
nation-states which have sufficient resources. Leave it to science fiction to
be the best weapon against magic!)

How well all of the assumptions underlying asymmetric
crypto\index{asymmetric cryptosystem} stand the test of time, and whether
practical, quantum-resistant \ix{asymmetric cryptosystem}s can be designed
and implemented is a question of enormous importance in the next decade(s) of
history of the Internet. While that cliff-hanger is being resolved by
hard-working technologists behind the scenes, there are other exotic
applications of asymmetric crypto\index{asymmetric cryptosystem} which have
been developed and which offer amazing potential benefits ... some which are,
indeed, almost certainly too good to be true.

One example of this is something that has come to be widely discussed recently,
called a \textbf{\ix{blockchain}}, which you have probably heard of as the
architecture underlying the \ix{cryptocurrency} \textbf{\ix{Bitcoin}}.  If you
worked in education, you would also have heard of \ix{blockchain}s as,
supposedly, the best place for high school diplomas, college transcripts, and
professional certificates to be stored.

A \ix{blockchain} starts with a data structure called a
\textbf{\ix{hash chain}}, which is basically just a sequence of data blocks
that can keep growing (potentially forever), with one additional field in each
block: the hash (under some cryptographic \ix{hash function}) of the previous
block.  Note that since that previous block contained the hash of the block
which preceded it, these hashes implicitly link all the blocks back to the
very first block of the chain, which is often called
\textbf{\ix{genesis block}}.

Graphically:

\vskip-13mm
\begin{adjustbox}{center}
\begin{tikzpicture}[auto]
  \path (0,0) node[place,draw] (gen) {Genesis block:
    \nodepart{second}
    \ \\
    data\\
    \ 
    \nodepart{third}
    null}
  (5,0) node[place,draw] (one) {Block 1:
    \nodepart{second}
    \ \\
    data\\
    \ 
    \nodepart{third}
    \phantom{X}}
  (10,0) node[place,draw] (two) {Block 2:
    \nodepart{second}
    \ \\
    data\\
    \ 
    \nodepart{third}
    \phantom{X}}
  (14,0) node (dots) {\textbf{.\ .\ .\ .}};;
  \draw[<-*] (gen) to [out=90,in=270] node[above,sloped] {hash of} ([yshift=-8.5mm] one);
  \draw[<-*] (one) to [out=90,in=270] node[above,sloped] {hash of} ([yshift=-8.5mm] two);
  \draw[<-*] (two) to [out=90,in=270] node[above,sloped] {hash of} (dots);
\end{tikzpicture}
\end{adjustbox}


The security properties of cryptographic \ix{hash function}s given in
Definition~\ref{def:hashfunction} give \ix{hash chain}s a remarkable property:
they are \textbf{\ix{immutable}}, meaning they cannot be changed. Specifically,
what that means is that if a whole bunch of people (call them ``the hobbits'')
are sharing copies of a hash chain, then someone else (call this person
``Gollum'') cannot come to them and pretend that they have a valid copy of the
chain which is the same at the beginning and the end, but has some extra blocks
added in the middle.  The reason this is impossible is that the first
block -- say it's block number 141592 near the end where Gollum agrees with the
hobbits would have the hash of two different ``previous'' blocks: the hobbits
would just have the same block they all agree is number 141591, while Gollum
would have that extra block he was trying to sneak into the chain ... and those
two different pieces of data cannot have the same hash (or, at least, it is very
hard to figure out what data should be in the block to make it have the same
hash value).

\vskip2mm
\begin{AZtcb}[label=az:hashchain]{}{}
  Does all of this make sense?  What was new or interesting, or what was old
  and uninteresting?  Do you feel comfortable with the ideas of a hash chain,
  and with why it is immutable?
\end{AZtcb}

\vskip2mm
Several additional features make a \ix{hash chain} into a \ix{blockchain}.
These include the fact that parts of the data in the blocks must have valid
\ix{digital signature}s\index{signature!digital} -- a topic we have discussed
in this chapter! -- and that the new blocks are the result of a
\textbf{\ix{consensus protocol}}.  Such protocols enable everyone who gets a
copy of the \ix{blockchain} to have confidence that they have the same chain
of data blocks as everyone else who is using that \ix{blockchain}.

Consensus protocols\index{consensus protocol} are a topic in even more
advanced cryptology classes: don't stop here, there is much more that is
fun, useful, and powerful to learn about in this field!

\backmatter

\bibliographystyle{amsalpha}
\bibliography{refs}

\index{cryptographic hash function!see{hash function}}
\printindex

\end{document}
